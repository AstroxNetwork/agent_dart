// This file is automatically generated, so please do not edit it.
// @generated by `flutter_rust_bridge`@ 2.10.0.

// ignore_for_file: unused_import, unused_element, unnecessary_import, duplicate_ignore, invalid_use_of_internal_member, annotate_overrides, non_constant_identifier_names, curly_braces_in_flow_control_structures, prefer_const_literals_to_create_immutables, unused_field

import 'api.dart';
import 'dart:async';
import 'dart:convert';
import 'frb_generated.dart';
import 'frb_generated.io.dart'
    if (dart.library.js_interop) 'frb_generated.web.dart';
import 'p256.dart';
import 'package:flutter_rust_bridge/flutter_rust_bridge_for_generated.dart';
import 'schnorr.dart';
import 'secp256k1.dart';
import 'types.dart';

/// Main entrypoint of the Rust API
class AgentDart
    extends BaseEntrypoint<AgentDartApi, AgentDartApiImpl, AgentDartWire> {
  @internal
  static final instance = AgentDart._();

  AgentDart._();

  /// Initialize flutter_rust_bridge
  static Future<void> init({
    AgentDartApi? api,
    BaseHandler? handler,
    ExternalLibrary? externalLibrary,
  }) async {
    await instance.initImpl(
      api: api,
      handler: handler,
      externalLibrary: externalLibrary,
    );
  }

  /// Initialize flutter_rust_bridge in mock mode.
  /// No libraries for FFI are loaded.
  static void initMock({
    required AgentDartApi api,
  }) {
    instance.initMockImpl(
      api: api,
    );
  }

  /// Dispose flutter_rust_bridge
  ///
  /// The call to this function is optional, since flutter_rust_bridge (and everything else)
  /// is automatically disposed when the app stops.
  static void dispose() => instance.disposeImpl();

  @override
  ApiImplConstructor<AgentDartApiImpl, AgentDartWire> get apiImplConstructor =>
      AgentDartApiImpl.new;

  @override
  WireConstructor<AgentDartWire> get wireConstructor =>
      AgentDartWire.fromExternalLibrary;

  @override
  Future<void> executeRustInitializers() async {}

  @override
  ExternalLibraryLoaderConfig get defaultExternalLibraryLoaderConfig =>
      kDefaultExternalLibraryLoaderConfig;

  @override
  String get codegenVersion => '2.10.0';

  @override
  int get rustContentHash => 796173266;

  static const kDefaultExternalLibraryLoaderConfig =
      ExternalLibraryLoaderConfig(
    stem: 'agent_dart',
    ioDirectory: 'native/agent_dart/target/release/',
    webPrefix: 'pkg/',
  );
}

abstract class AgentDartApi extends BaseApi {
  Future<Uint8List> crateApiAes128CtrDecrypt({required AesDecryptReq req});

  Future<Uint8List> crateApiAes128CtrEncrypt({required AesEncryptReq req});

  Future<Uint8List> crateApiAes256CbcDecrypt({required AesDecryptReq req});

  Future<Uint8List> crateApiAes256CbcEncrypt({required AesEncryptReq req});

  Future<Uint8List> crateApiAes256GcmDecrypt({required AesDecryptReq req});

  Future<Uint8List> crateApiAes256GcmEncrypt({required AesEncryptReq req});

  Future<bool> crateApiBlsInit();

  Future<bool> crateApiBlsVerify({required BLSVerifyReq req});

  Future<ED25519Res> crateApiEd25519FromSeed({required ED25519FromSeedReq req});

  Future<Uint8List> crateApiEd25519Sign({required ED25519SignReq req});

  Future<bool> crateApiEd25519Verify({required ED25519VerifyReq req});

  Future<Uint8List> crateApiMnemonicPhraseToSeed(
      {required PhraseToSeedReq req});

  Future<Uint8List> crateApiMnemonicSeedToKey({required SeedToKeyReq req});

  Future<P256IdentityExport> crateApiP256FromSeed(
      {required P256FromSeedReq req});

  Future<Uint8List> crateApiP256GetSharedSecret(
      {required P256ShareSecretReq req});

  Future<SignatureFFI> crateApiP256Sign({required P256SignWithSeedReq req});

  Future<bool> crateApiP256Verify({required P256VerifyReq req});

  Future<KeyDerivedRes> crateApiPbkdf2DeriveKey({required PBKDFDeriveReq req});

  Future<SchnorrIdentityExport> crateApiSchnorrFromSeed(
      {required SchnorrFromSeedReq req});

  Future<SignatureFFI> crateApiSchnorrSign(
      {required SchnorrSignWithSeedReq req});

  Future<bool> crateApiSchnorrVerify({required SchnorrVerifyReq req});

  Future<KeyDerivedRes> crateApiScryptDeriveKey({required ScriptDeriveReq req});

  Future<Secp256k1IdentityExport> crateApiSecp256K1FromSeed(
      {required Secp256k1FromSeedReq req});

  Future<Uint8List> crateApiSecp256K1GetSharedSecret(
      {required Secp256k1ShareSecretReq req});

  Future<Uint8List> crateApiSecp256K1Recover(
      {required Secp256k1RecoverReq req});

  Future<SignatureFFI> crateApiSecp256K1Sign(
      {required Secp256k1SignWithSeedReq req});

  Future<SignatureFFI> crateApiSecp256K1SignRecoverable(
      {required Secp256k1SignWithSeedReq req});

  Future<SignatureFFI> crateApiSecp256K1SignWithRng(
      {required Secp256k1SignWithRngReq req});

  Future<bool> crateApiSecp256K1Verify({required Secp256k1VerifyReq req});
}

class AgentDartApiImpl extends AgentDartApiImplPlatform
    implements AgentDartApi {
  AgentDartApiImpl({
    required super.handler,
    required super.wire,
    required super.generalizedFrbRustBinding,
    required super.portManager,
  });

  @override
  Future<Uint8List> crateApiAes128CtrDecrypt({required AesDecryptReq req}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_box_autoadd_aes_decrypt_req(req, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 1, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_list_prim_u_8_strict,
        decodeErrorData: null,
      ),
      constMeta: kCrateApiAes128CtrDecryptConstMeta,
      argValues: [req],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiAes128CtrDecryptConstMeta => const TaskConstMeta(
        debugName: "aes_128_ctr_decrypt",
        argNames: ["req"],
      );

  @override
  Future<Uint8List> crateApiAes128CtrEncrypt({required AesEncryptReq req}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_box_autoadd_aes_encrypt_req(req, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 2, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_list_prim_u_8_strict,
        decodeErrorData: null,
      ),
      constMeta: kCrateApiAes128CtrEncryptConstMeta,
      argValues: [req],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiAes128CtrEncryptConstMeta => const TaskConstMeta(
        debugName: "aes_128_ctr_encrypt",
        argNames: ["req"],
      );

  @override
  Future<Uint8List> crateApiAes256CbcDecrypt({required AesDecryptReq req}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_box_autoadd_aes_decrypt_req(req, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 3, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_list_prim_u_8_strict,
        decodeErrorData: null,
      ),
      constMeta: kCrateApiAes256CbcDecryptConstMeta,
      argValues: [req],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiAes256CbcDecryptConstMeta => const TaskConstMeta(
        debugName: "aes_256_cbc_decrypt",
        argNames: ["req"],
      );

  @override
  Future<Uint8List> crateApiAes256CbcEncrypt({required AesEncryptReq req}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_box_autoadd_aes_encrypt_req(req, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 4, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_list_prim_u_8_strict,
        decodeErrorData: null,
      ),
      constMeta: kCrateApiAes256CbcEncryptConstMeta,
      argValues: [req],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiAes256CbcEncryptConstMeta => const TaskConstMeta(
        debugName: "aes_256_cbc_encrypt",
        argNames: ["req"],
      );

  @override
  Future<Uint8List> crateApiAes256GcmDecrypt({required AesDecryptReq req}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_box_autoadd_aes_decrypt_req(req, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 5, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_list_prim_u_8_strict,
        decodeErrorData: null,
      ),
      constMeta: kCrateApiAes256GcmDecryptConstMeta,
      argValues: [req],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiAes256GcmDecryptConstMeta => const TaskConstMeta(
        debugName: "aes_256_gcm_decrypt",
        argNames: ["req"],
      );

  @override
  Future<Uint8List> crateApiAes256GcmEncrypt({required AesEncryptReq req}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_box_autoadd_aes_encrypt_req(req, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 6, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_list_prim_u_8_strict,
        decodeErrorData: null,
      ),
      constMeta: kCrateApiAes256GcmEncryptConstMeta,
      argValues: [req],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiAes256GcmEncryptConstMeta => const TaskConstMeta(
        debugName: "aes_256_gcm_encrypt",
        argNames: ["req"],
      );

  @override
  Future<bool> crateApiBlsInit() {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 7, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_bool,
        decodeErrorData: null,
      ),
      constMeta: kCrateApiBlsInitConstMeta,
      argValues: [],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiBlsInitConstMeta => const TaskConstMeta(
        debugName: "bls_init",
        argNames: [],
      );

  @override
  Future<bool> crateApiBlsVerify({required BLSVerifyReq req}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_box_autoadd_bls_verify_req(req, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 8, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_bool,
        decodeErrorData: null,
      ),
      constMeta: kCrateApiBlsVerifyConstMeta,
      argValues: [req],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiBlsVerifyConstMeta => const TaskConstMeta(
        debugName: "bls_verify",
        argNames: ["req"],
      );

  @override
  Future<ED25519Res> crateApiEd25519FromSeed(
      {required ED25519FromSeedReq req}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_box_autoadd_ed_25519_from_seed_req(req, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 9, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_ed_25519_res,
        decodeErrorData: null,
      ),
      constMeta: kCrateApiEd25519FromSeedConstMeta,
      argValues: [req],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiEd25519FromSeedConstMeta => const TaskConstMeta(
        debugName: "ed25519_from_seed",
        argNames: ["req"],
      );

  @override
  Future<Uint8List> crateApiEd25519Sign({required ED25519SignReq req}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_box_autoadd_ed_25519_sign_req(req, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 10, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_list_prim_u_8_strict,
        decodeErrorData: null,
      ),
      constMeta: kCrateApiEd25519SignConstMeta,
      argValues: [req],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiEd25519SignConstMeta => const TaskConstMeta(
        debugName: "ed25519_sign",
        argNames: ["req"],
      );

  @override
  Future<bool> crateApiEd25519Verify({required ED25519VerifyReq req}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_box_autoadd_ed_25519_verify_req(req, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 11, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_bool,
        decodeErrorData: null,
      ),
      constMeta: kCrateApiEd25519VerifyConstMeta,
      argValues: [req],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiEd25519VerifyConstMeta => const TaskConstMeta(
        debugName: "ed25519_verify",
        argNames: ["req"],
      );

  @override
  Future<Uint8List> crateApiMnemonicPhraseToSeed(
      {required PhraseToSeedReq req}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_box_autoadd_phrase_to_seed_req(req, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 12, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_list_prim_u_8_strict,
        decodeErrorData: null,
      ),
      constMeta: kCrateApiMnemonicPhraseToSeedConstMeta,
      argValues: [req],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiMnemonicPhraseToSeedConstMeta =>
      const TaskConstMeta(
        debugName: "mnemonic_phrase_to_seed",
        argNames: ["req"],
      );

  @override
  Future<Uint8List> crateApiMnemonicSeedToKey({required SeedToKeyReq req}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_box_autoadd_seed_to_key_req(req, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 13, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_list_prim_u_8_strict,
        decodeErrorData: null,
      ),
      constMeta: kCrateApiMnemonicSeedToKeyConstMeta,
      argValues: [req],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiMnemonicSeedToKeyConstMeta => const TaskConstMeta(
        debugName: "mnemonic_seed_to_key",
        argNames: ["req"],
      );

  @override
  Future<P256IdentityExport> crateApiP256FromSeed(
      {required P256FromSeedReq req}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_box_autoadd_p_256_from_seed_req(req, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 14, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_p_256_identity_export,
        decodeErrorData: null,
      ),
      constMeta: kCrateApiP256FromSeedConstMeta,
      argValues: [req],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiP256FromSeedConstMeta => const TaskConstMeta(
        debugName: "p256_from_seed",
        argNames: ["req"],
      );

  @override
  Future<Uint8List> crateApiP256GetSharedSecret(
      {required P256ShareSecretReq req}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_box_autoadd_p_256_share_secret_req(req, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 15, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_list_prim_u_8_strict,
        decodeErrorData: null,
      ),
      constMeta: kCrateApiP256GetSharedSecretConstMeta,
      argValues: [req],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiP256GetSharedSecretConstMeta =>
      const TaskConstMeta(
        debugName: "p256_get_shared_secret",
        argNames: ["req"],
      );

  @override
  Future<SignatureFFI> crateApiP256Sign({required P256SignWithSeedReq req}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_box_autoadd_p_256_sign_with_seed_req(req, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 16, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_signature_ffi,
        decodeErrorData: null,
      ),
      constMeta: kCrateApiP256SignConstMeta,
      argValues: [req],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiP256SignConstMeta => const TaskConstMeta(
        debugName: "p256_sign",
        argNames: ["req"],
      );

  @override
  Future<bool> crateApiP256Verify({required P256VerifyReq req}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_box_autoadd_p_256_verify_req(req, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 17, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_bool,
        decodeErrorData: null,
      ),
      constMeta: kCrateApiP256VerifyConstMeta,
      argValues: [req],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiP256VerifyConstMeta => const TaskConstMeta(
        debugName: "p256_verify",
        argNames: ["req"],
      );

  @override
  Future<KeyDerivedRes> crateApiPbkdf2DeriveKey({required PBKDFDeriveReq req}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_box_autoadd_pbkdf_derive_req(req, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 18, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_key_derived_res,
        decodeErrorData: null,
      ),
      constMeta: kCrateApiPbkdf2DeriveKeyConstMeta,
      argValues: [req],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiPbkdf2DeriveKeyConstMeta => const TaskConstMeta(
        debugName: "pbkdf2_derive_key",
        argNames: ["req"],
      );

  @override
  Future<SchnorrIdentityExport> crateApiSchnorrFromSeed(
      {required SchnorrFromSeedReq req}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_box_autoadd_schnorr_from_seed_req(req, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 19, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_schnorr_identity_export,
        decodeErrorData: null,
      ),
      constMeta: kCrateApiSchnorrFromSeedConstMeta,
      argValues: [req],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiSchnorrFromSeedConstMeta => const TaskConstMeta(
        debugName: "schnorr_from_seed",
        argNames: ["req"],
      );

  @override
  Future<SignatureFFI> crateApiSchnorrSign(
      {required SchnorrSignWithSeedReq req}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_box_autoadd_schnorr_sign_with_seed_req(req, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 20, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_signature_ffi,
        decodeErrorData: null,
      ),
      constMeta: kCrateApiSchnorrSignConstMeta,
      argValues: [req],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiSchnorrSignConstMeta => const TaskConstMeta(
        debugName: "schnorr_sign",
        argNames: ["req"],
      );

  @override
  Future<bool> crateApiSchnorrVerify({required SchnorrVerifyReq req}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_box_autoadd_schnorr_verify_req(req, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 21, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_bool,
        decodeErrorData: null,
      ),
      constMeta: kCrateApiSchnorrVerifyConstMeta,
      argValues: [req],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiSchnorrVerifyConstMeta => const TaskConstMeta(
        debugName: "schnorr_verify",
        argNames: ["req"],
      );

  @override
  Future<KeyDerivedRes> crateApiScryptDeriveKey(
      {required ScriptDeriveReq req}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_box_autoadd_script_derive_req(req, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 22, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_key_derived_res,
        decodeErrorData: null,
      ),
      constMeta: kCrateApiScryptDeriveKeyConstMeta,
      argValues: [req],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiScryptDeriveKeyConstMeta => const TaskConstMeta(
        debugName: "scrypt_derive_key",
        argNames: ["req"],
      );

  @override
  Future<Secp256k1IdentityExport> crateApiSecp256K1FromSeed(
      {required Secp256k1FromSeedReq req}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_box_autoadd_secp_256_k_1_from_seed_req(req, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 23, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_secp_256_k_1_identity_export,
        decodeErrorData: null,
      ),
      constMeta: kCrateApiSecp256K1FromSeedConstMeta,
      argValues: [req],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiSecp256K1FromSeedConstMeta => const TaskConstMeta(
        debugName: "secp256k1_from_seed",
        argNames: ["req"],
      );

  @override
  Future<Uint8List> crateApiSecp256K1GetSharedSecret(
      {required Secp256k1ShareSecretReq req}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_box_autoadd_secp_256_k_1_share_secret_req(req, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 24, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_list_prim_u_8_strict,
        decodeErrorData: null,
      ),
      constMeta: kCrateApiSecp256K1GetSharedSecretConstMeta,
      argValues: [req],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiSecp256K1GetSharedSecretConstMeta =>
      const TaskConstMeta(
        debugName: "secp256k1_get_shared_secret",
        argNames: ["req"],
      );

  @override
  Future<Uint8List> crateApiSecp256K1Recover(
      {required Secp256k1RecoverReq req}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_box_autoadd_secp_256_k_1_recover_req(req, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 25, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_list_prim_u_8_strict,
        decodeErrorData: null,
      ),
      constMeta: kCrateApiSecp256K1RecoverConstMeta,
      argValues: [req],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiSecp256K1RecoverConstMeta => const TaskConstMeta(
        debugName: "secp256k1_recover",
        argNames: ["req"],
      );

  @override
  Future<SignatureFFI> crateApiSecp256K1Sign(
      {required Secp256k1SignWithSeedReq req}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_box_autoadd_secp_256_k_1_sign_with_seed_req(req, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 26, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_signature_ffi,
        decodeErrorData: null,
      ),
      constMeta: kCrateApiSecp256K1SignConstMeta,
      argValues: [req],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiSecp256K1SignConstMeta => const TaskConstMeta(
        debugName: "secp256k1_sign",
        argNames: ["req"],
      );

  @override
  Future<SignatureFFI> crateApiSecp256K1SignRecoverable(
      {required Secp256k1SignWithSeedReq req}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_box_autoadd_secp_256_k_1_sign_with_seed_req(req, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 27, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_signature_ffi,
        decodeErrorData: null,
      ),
      constMeta: kCrateApiSecp256K1SignRecoverableConstMeta,
      argValues: [req],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiSecp256K1SignRecoverableConstMeta =>
      const TaskConstMeta(
        debugName: "secp256k1_sign_recoverable",
        argNames: ["req"],
      );

  @override
  Future<SignatureFFI> crateApiSecp256K1SignWithRng(
      {required Secp256k1SignWithRngReq req}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_box_autoadd_secp_256_k_1_sign_with_rng_req(req, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 28, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_signature_ffi,
        decodeErrorData: null,
      ),
      constMeta: kCrateApiSecp256K1SignWithRngConstMeta,
      argValues: [req],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiSecp256K1SignWithRngConstMeta =>
      const TaskConstMeta(
        debugName: "secp256k1_sign_with_rng",
        argNames: ["req"],
      );

  @override
  Future<bool> crateApiSecp256K1Verify({required Secp256k1VerifyReq req}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_box_autoadd_secp_256_k_1_verify_req(req, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 29, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_bool,
        decodeErrorData: null,
      ),
      constMeta: kCrateApiSecp256K1VerifyConstMeta,
      argValues: [req],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiSecp256K1VerifyConstMeta => const TaskConstMeta(
        debugName: "secp256k1_verify",
        argNames: ["req"],
      );

  @protected
  String dco_decode_String(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw as String;
  }

  @protected
  AesDecryptReq dco_decode_aes_decrypt_req(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 3)
      throw Exception('unexpected arr length: expect 3 but see ${arr.length}');
    return AesDecryptReq(
      key: dco_decode_list_prim_u_8_strict(arr[0]),
      iv: dco_decode_list_prim_u_8_strict(arr[1]),
      cipherText: dco_decode_list_prim_u_8_strict(arr[2]),
    );
  }

  @protected
  AesEncryptReq dco_decode_aes_encrypt_req(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 3)
      throw Exception('unexpected arr length: expect 3 but see ${arr.length}');
    return AesEncryptReq(
      key: dco_decode_list_prim_u_8_strict(arr[0]),
      iv: dco_decode_list_prim_u_8_strict(arr[1]),
      message: dco_decode_list_prim_u_8_strict(arr[2]),
    );
  }

  @protected
  BLSVerifyReq dco_decode_bls_verify_req(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 3)
      throw Exception('unexpected arr length: expect 3 but see ${arr.length}');
    return BLSVerifyReq(
      signature: dco_decode_list_prim_u_8_strict(arr[0]),
      message: dco_decode_list_prim_u_8_strict(arr[1]),
      publicKey: dco_decode_list_prim_u_8_strict(arr[2]),
    );
  }

  @protected
  bool dco_decode_bool(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw as bool;
  }

  @protected
  AesDecryptReq dco_decode_box_autoadd_aes_decrypt_req(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_aes_decrypt_req(raw);
  }

  @protected
  AesEncryptReq dco_decode_box_autoadd_aes_encrypt_req(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_aes_encrypt_req(raw);
  }

  @protected
  BLSVerifyReq dco_decode_box_autoadd_bls_verify_req(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_bls_verify_req(raw);
  }

  @protected
  ED25519FromSeedReq dco_decode_box_autoadd_ed_25519_from_seed_req(
      dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_ed_25519_from_seed_req(raw);
  }

  @protected
  ED25519SignReq dco_decode_box_autoadd_ed_25519_sign_req(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_ed_25519_sign_req(raw);
  }

  @protected
  ED25519VerifyReq dco_decode_box_autoadd_ed_25519_verify_req(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_ed_25519_verify_req(raw);
  }

  @protected
  P256FromSeedReq dco_decode_box_autoadd_p_256_from_seed_req(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_p_256_from_seed_req(raw);
  }

  @protected
  P256ShareSecretReq dco_decode_box_autoadd_p_256_share_secret_req(
      dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_p_256_share_secret_req(raw);
  }

  @protected
  P256SignWithSeedReq dco_decode_box_autoadd_p_256_sign_with_seed_req(
      dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_p_256_sign_with_seed_req(raw);
  }

  @protected
  P256VerifyReq dco_decode_box_autoadd_p_256_verify_req(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_p_256_verify_req(raw);
  }

  @protected
  PBKDFDeriveReq dco_decode_box_autoadd_pbkdf_derive_req(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_pbkdf_derive_req(raw);
  }

  @protected
  PhraseToSeedReq dco_decode_box_autoadd_phrase_to_seed_req(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_phrase_to_seed_req(raw);
  }

  @protected
  SchnorrFromSeedReq dco_decode_box_autoadd_schnorr_from_seed_req(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_schnorr_from_seed_req(raw);
  }

  @protected
  SchnorrSignWithSeedReq dco_decode_box_autoadd_schnorr_sign_with_seed_req(
      dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_schnorr_sign_with_seed_req(raw);
  }

  @protected
  SchnorrVerifyReq dco_decode_box_autoadd_schnorr_verify_req(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_schnorr_verify_req(raw);
  }

  @protected
  ScriptDeriveReq dco_decode_box_autoadd_script_derive_req(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_script_derive_req(raw);
  }

  @protected
  Secp256k1FromSeedReq dco_decode_box_autoadd_secp_256_k_1_from_seed_req(
      dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_secp_256_k_1_from_seed_req(raw);
  }

  @protected
  Secp256k1RecoverReq dco_decode_box_autoadd_secp_256_k_1_recover_req(
      dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_secp_256_k_1_recover_req(raw);
  }

  @protected
  Secp256k1ShareSecretReq dco_decode_box_autoadd_secp_256_k_1_share_secret_req(
      dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_secp_256_k_1_share_secret_req(raw);
  }

  @protected
  Secp256k1SignWithRngReq dco_decode_box_autoadd_secp_256_k_1_sign_with_rng_req(
      dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_secp_256_k_1_sign_with_rng_req(raw);
  }

  @protected
  Secp256k1SignWithSeedReq
      dco_decode_box_autoadd_secp_256_k_1_sign_with_seed_req(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_secp_256_k_1_sign_with_seed_req(raw);
  }

  @protected
  Secp256k1VerifyReq dco_decode_box_autoadd_secp_256_k_1_verify_req(
      dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_secp_256_k_1_verify_req(raw);
  }

  @protected
  SeedToKeyReq dco_decode_box_autoadd_seed_to_key_req(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_seed_to_key_req(raw);
  }

  @protected
  int dco_decode_box_autoadd_u_8(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw as int;
  }

  @protected
  ED25519FromSeedReq dco_decode_ed_25519_from_seed_req(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 1)
      throw Exception('unexpected arr length: expect 1 but see ${arr.length}');
    return ED25519FromSeedReq(
      seed: dco_decode_list_prim_u_8_strict(arr[0]),
    );
  }

  @protected
  ED25519Res dco_decode_ed_25519_res(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 2)
      throw Exception('unexpected arr length: expect 2 but see ${arr.length}');
    return ED25519Res(
      seed: dco_decode_list_prim_u_8_strict(arr[0]),
      publicKey: dco_decode_list_prim_u_8_strict(arr[1]),
    );
  }

  @protected
  ED25519SignReq dco_decode_ed_25519_sign_req(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 2)
      throw Exception('unexpected arr length: expect 2 but see ${arr.length}');
    return ED25519SignReq(
      seed: dco_decode_list_prim_u_8_strict(arr[0]),
      message: dco_decode_list_prim_u_8_strict(arr[1]),
    );
  }

  @protected
  ED25519VerifyReq dco_decode_ed_25519_verify_req(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 3)
      throw Exception('unexpected arr length: expect 3 but see ${arr.length}');
    return ED25519VerifyReq(
      sig: dco_decode_list_prim_u_8_strict(arr[0]),
      message: dco_decode_list_prim_u_8_strict(arr[1]),
      pubKey: dco_decode_list_prim_u_8_strict(arr[2]),
    );
  }

  @protected
  KeyDerivedRes dco_decode_key_derived_res(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 2)
      throw Exception('unexpected arr length: expect 2 but see ${arr.length}');
    return KeyDerivedRes(
      leftBits: dco_decode_list_prim_u_8_strict(arr[0]),
      rightBits: dco_decode_list_prim_u_8_strict(arr[1]),
    );
  }

  @protected
  Uint8List dco_decode_list_prim_u_8_strict(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw as Uint8List;
  }

  @protected
  int? dco_decode_opt_box_autoadd_u_8(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw == null ? null : dco_decode_box_autoadd_u_8(raw);
  }

  @protected
  Uint8List? dco_decode_opt_list_prim_u_8_strict(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw == null ? null : dco_decode_list_prim_u_8_strict(raw);
  }

  @protected
  P256FromSeedReq dco_decode_p_256_from_seed_req(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 1)
      throw Exception('unexpected arr length: expect 1 but see ${arr.length}');
    return P256FromSeedReq(
      seed: dco_decode_list_prim_u_8_strict(arr[0]),
    );
  }

  @protected
  P256IdentityExport dco_decode_p_256_identity_export(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 2)
      throw Exception('unexpected arr length: expect 2 but see ${arr.length}');
    return P256IdentityExport(
      privateKeyHash: dco_decode_list_prim_u_8_strict(arr[0]),
      derEncodedPublicKey: dco_decode_list_prim_u_8_strict(arr[1]),
    );
  }

  @protected
  P256ShareSecretReq dco_decode_p_256_share_secret_req(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 2)
      throw Exception('unexpected arr length: expect 2 but see ${arr.length}');
    return P256ShareSecretReq(
      seed: dco_decode_list_prim_u_8_strict(arr[0]),
      publicKeyRawBytes: dco_decode_list_prim_u_8_strict(arr[1]),
    );
  }

  @protected
  P256SignWithSeedReq dco_decode_p_256_sign_with_seed_req(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 2)
      throw Exception('unexpected arr length: expect 2 but see ${arr.length}');
    return P256SignWithSeedReq(
      msg: dco_decode_list_prim_u_8_strict(arr[0]),
      seed: dco_decode_list_prim_u_8_strict(arr[1]),
    );
  }

  @protected
  P256VerifyReq dco_decode_p_256_verify_req(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 3)
      throw Exception('unexpected arr length: expect 3 but see ${arr.length}');
    return P256VerifyReq(
      messageHash: dco_decode_list_prim_u_8_strict(arr[0]),
      signatureBytes: dco_decode_list_prim_u_8_strict(arr[1]),
      publicKeyBytes: dco_decode_list_prim_u_8_strict(arr[2]),
    );
  }

  @protected
  PBKDFDeriveReq dco_decode_pbkdf_derive_req(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 3)
      throw Exception('unexpected arr length: expect 3 but see ${arr.length}');
    return PBKDFDeriveReq(
      password: dco_decode_list_prim_u_8_strict(arr[0]),
      salt: dco_decode_list_prim_u_8_strict(arr[1]),
      c: dco_decode_u_32(arr[2]),
    );
  }

  @protected
  PhraseToSeedReq dco_decode_phrase_to_seed_req(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 2)
      throw Exception('unexpected arr length: expect 2 but see ${arr.length}');
    return PhraseToSeedReq(
      phrase: dco_decode_String(arr[0]),
      password: dco_decode_String(arr[1]),
    );
  }

  @protected
  SchnorrFromSeedReq dco_decode_schnorr_from_seed_req(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 1)
      throw Exception('unexpected arr length: expect 1 but see ${arr.length}');
    return SchnorrFromSeedReq(
      seed: dco_decode_list_prim_u_8_strict(arr[0]),
    );
  }

  @protected
  SchnorrIdentityExport dco_decode_schnorr_identity_export(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 2)
      throw Exception('unexpected arr length: expect 2 but see ${arr.length}');
    return SchnorrIdentityExport(
      privateKeyHash: dco_decode_list_prim_u_8_strict(arr[0]),
      publicKeyHash: dco_decode_list_prim_u_8_strict(arr[1]),
    );
  }

  @protected
  SchnorrSignWithSeedReq dco_decode_schnorr_sign_with_seed_req(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 3)
      throw Exception('unexpected arr length: expect 3 but see ${arr.length}');
    return SchnorrSignWithSeedReq(
      msg: dco_decode_list_prim_u_8_strict(arr[0]),
      seed: dco_decode_list_prim_u_8_strict(arr[1]),
      auxRand: dco_decode_opt_list_prim_u_8_strict(arr[2]),
    );
  }

  @protected
  SchnorrVerifyReq dco_decode_schnorr_verify_req(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 3)
      throw Exception('unexpected arr length: expect 3 but see ${arr.length}');
    return SchnorrVerifyReq(
      messageHash: dco_decode_list_prim_u_8_strict(arr[0]),
      signatureBytes: dco_decode_list_prim_u_8_strict(arr[1]),
      publicKeyBytes: dco_decode_list_prim_u_8_strict(arr[2]),
    );
  }

  @protected
  ScriptDeriveReq dco_decode_script_derive_req(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 5)
      throw Exception('unexpected arr length: expect 5 but see ${arr.length}');
    return ScriptDeriveReq(
      password: dco_decode_list_prim_u_8_strict(arr[0]),
      salt: dco_decode_list_prim_u_8_strict(arr[1]),
      n: dco_decode_u_32(arr[2]),
      p: dco_decode_u_32(arr[3]),
      r: dco_decode_u_32(arr[4]),
    );
  }

  @protected
  Secp256k1FromSeedReq dco_decode_secp_256_k_1_from_seed_req(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 1)
      throw Exception('unexpected arr length: expect 1 but see ${arr.length}');
    return Secp256k1FromSeedReq(
      seed: dco_decode_list_prim_u_8_strict(arr[0]),
    );
  }

  @protected
  Secp256k1IdentityExport dco_decode_secp_256_k_1_identity_export(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 2)
      throw Exception('unexpected arr length: expect 2 but see ${arr.length}');
    return Secp256k1IdentityExport(
      privateKeyHash: dco_decode_list_prim_u_8_strict(arr[0]),
      derEncodedPublicKey: dco_decode_list_prim_u_8_strict(arr[1]),
    );
  }

  @protected
  Secp256k1RecoverReq dco_decode_secp_256_k_1_recover_req(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 3)
      throw Exception('unexpected arr length: expect 3 but see ${arr.length}');
    return Secp256k1RecoverReq(
      messagePreHashed: dco_decode_list_prim_u_8_strict(arr[0]),
      signatureBytes: dco_decode_list_prim_u_8_strict(arr[1]),
      chainId: dco_decode_opt_box_autoadd_u_8(arr[2]),
    );
  }

  @protected
  Secp256k1ShareSecretReq dco_decode_secp_256_k_1_share_secret_req(
      dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 2)
      throw Exception('unexpected arr length: expect 2 but see ${arr.length}');
    return Secp256k1ShareSecretReq(
      seed: dco_decode_list_prim_u_8_strict(arr[0]),
      publicKeyRawBytes: dco_decode_list_prim_u_8_strict(arr[1]),
    );
  }

  @protected
  Secp256k1SignWithRngReq dco_decode_secp_256_k_1_sign_with_rng_req(
      dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 2)
      throw Exception('unexpected arr length: expect 2 but see ${arr.length}');
    return Secp256k1SignWithRngReq(
      msg: dco_decode_list_prim_u_8_strict(arr[0]),
      privateBytes: dco_decode_list_prim_u_8_strict(arr[1]),
    );
  }

  @protected
  Secp256k1SignWithSeedReq dco_decode_secp_256_k_1_sign_with_seed_req(
      dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 2)
      throw Exception('unexpected arr length: expect 2 but see ${arr.length}');
    return Secp256k1SignWithSeedReq(
      msg: dco_decode_list_prim_u_8_strict(arr[0]),
      seed: dco_decode_list_prim_u_8_strict(arr[1]),
    );
  }

  @protected
  Secp256k1VerifyReq dco_decode_secp_256_k_1_verify_req(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 3)
      throw Exception('unexpected arr length: expect 3 but see ${arr.length}');
    return Secp256k1VerifyReq(
      messageHash: dco_decode_list_prim_u_8_strict(arr[0]),
      signatureBytes: dco_decode_list_prim_u_8_strict(arr[1]),
      publicKeyBytes: dco_decode_list_prim_u_8_strict(arr[2]),
    );
  }

  @protected
  SeedToKeyReq dco_decode_seed_to_key_req(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 2)
      throw Exception('unexpected arr length: expect 2 but see ${arr.length}');
    return SeedToKeyReq(
      seed: dco_decode_list_prim_u_8_strict(arr[0]),
      path: dco_decode_String(arr[1]),
    );
  }

  @protected
  SignatureFFI dco_decode_signature_ffi(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 2)
      throw Exception('unexpected arr length: expect 2 but see ${arr.length}');
    return SignatureFFI(
      publicKey: dco_decode_opt_list_prim_u_8_strict(arr[0]),
      signature: dco_decode_opt_list_prim_u_8_strict(arr[1]),
    );
  }

  @protected
  int dco_decode_u_32(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw as int;
  }

  @protected
  int dco_decode_u_8(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw as int;
  }

  @protected
  void dco_decode_unit(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return;
  }

  @protected
  String sse_decode_String(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var inner = sse_decode_list_prim_u_8_strict(deserializer);
    return utf8.decoder.convert(inner);
  }

  @protected
  AesDecryptReq sse_decode_aes_decrypt_req(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_key = sse_decode_list_prim_u_8_strict(deserializer);
    var var_iv = sse_decode_list_prim_u_8_strict(deserializer);
    var var_cipherText = sse_decode_list_prim_u_8_strict(deserializer);
    return AesDecryptReq(key: var_key, iv: var_iv, cipherText: var_cipherText);
  }

  @protected
  AesEncryptReq sse_decode_aes_encrypt_req(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_key = sse_decode_list_prim_u_8_strict(deserializer);
    var var_iv = sse_decode_list_prim_u_8_strict(deserializer);
    var var_message = sse_decode_list_prim_u_8_strict(deserializer);
    return AesEncryptReq(key: var_key, iv: var_iv, message: var_message);
  }

  @protected
  BLSVerifyReq sse_decode_bls_verify_req(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_signature = sse_decode_list_prim_u_8_strict(deserializer);
    var var_message = sse_decode_list_prim_u_8_strict(deserializer);
    var var_publicKey = sse_decode_list_prim_u_8_strict(deserializer);
    return BLSVerifyReq(
        signature: var_signature,
        message: var_message,
        publicKey: var_publicKey);
  }

  @protected
  bool sse_decode_bool(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return deserializer.buffer.getUint8() != 0;
  }

  @protected
  AesDecryptReq sse_decode_box_autoadd_aes_decrypt_req(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_aes_decrypt_req(deserializer));
  }

  @protected
  AesEncryptReq sse_decode_box_autoadd_aes_encrypt_req(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_aes_encrypt_req(deserializer));
  }

  @protected
  BLSVerifyReq sse_decode_box_autoadd_bls_verify_req(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_bls_verify_req(deserializer));
  }

  @protected
  ED25519FromSeedReq sse_decode_box_autoadd_ed_25519_from_seed_req(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_ed_25519_from_seed_req(deserializer));
  }

  @protected
  ED25519SignReq sse_decode_box_autoadd_ed_25519_sign_req(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_ed_25519_sign_req(deserializer));
  }

  @protected
  ED25519VerifyReq sse_decode_box_autoadd_ed_25519_verify_req(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_ed_25519_verify_req(deserializer));
  }

  @protected
  P256FromSeedReq sse_decode_box_autoadd_p_256_from_seed_req(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_p_256_from_seed_req(deserializer));
  }

  @protected
  P256ShareSecretReq sse_decode_box_autoadd_p_256_share_secret_req(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_p_256_share_secret_req(deserializer));
  }

  @protected
  P256SignWithSeedReq sse_decode_box_autoadd_p_256_sign_with_seed_req(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_p_256_sign_with_seed_req(deserializer));
  }

  @protected
  P256VerifyReq sse_decode_box_autoadd_p_256_verify_req(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_p_256_verify_req(deserializer));
  }

  @protected
  PBKDFDeriveReq sse_decode_box_autoadd_pbkdf_derive_req(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_pbkdf_derive_req(deserializer));
  }

  @protected
  PhraseToSeedReq sse_decode_box_autoadd_phrase_to_seed_req(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_phrase_to_seed_req(deserializer));
  }

  @protected
  SchnorrFromSeedReq sse_decode_box_autoadd_schnorr_from_seed_req(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_schnorr_from_seed_req(deserializer));
  }

  @protected
  SchnorrSignWithSeedReq sse_decode_box_autoadd_schnorr_sign_with_seed_req(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_schnorr_sign_with_seed_req(deserializer));
  }

  @protected
  SchnorrVerifyReq sse_decode_box_autoadd_schnorr_verify_req(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_schnorr_verify_req(deserializer));
  }

  @protected
  ScriptDeriveReq sse_decode_box_autoadd_script_derive_req(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_script_derive_req(deserializer));
  }

  @protected
  Secp256k1FromSeedReq sse_decode_box_autoadd_secp_256_k_1_from_seed_req(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_secp_256_k_1_from_seed_req(deserializer));
  }

  @protected
  Secp256k1RecoverReq sse_decode_box_autoadd_secp_256_k_1_recover_req(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_secp_256_k_1_recover_req(deserializer));
  }

  @protected
  Secp256k1ShareSecretReq sse_decode_box_autoadd_secp_256_k_1_share_secret_req(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_secp_256_k_1_share_secret_req(deserializer));
  }

  @protected
  Secp256k1SignWithRngReq sse_decode_box_autoadd_secp_256_k_1_sign_with_rng_req(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_secp_256_k_1_sign_with_rng_req(deserializer));
  }

  @protected
  Secp256k1SignWithSeedReq
      sse_decode_box_autoadd_secp_256_k_1_sign_with_seed_req(
          SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_secp_256_k_1_sign_with_seed_req(deserializer));
  }

  @protected
  Secp256k1VerifyReq sse_decode_box_autoadd_secp_256_k_1_verify_req(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_secp_256_k_1_verify_req(deserializer));
  }

  @protected
  SeedToKeyReq sse_decode_box_autoadd_seed_to_key_req(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_seed_to_key_req(deserializer));
  }

  @protected
  int sse_decode_box_autoadd_u_8(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_u_8(deserializer));
  }

  @protected
  ED25519FromSeedReq sse_decode_ed_25519_from_seed_req(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_seed = sse_decode_list_prim_u_8_strict(deserializer);
    return ED25519FromSeedReq(seed: var_seed);
  }

  @protected
  ED25519Res sse_decode_ed_25519_res(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_seed = sse_decode_list_prim_u_8_strict(deserializer);
    var var_publicKey = sse_decode_list_prim_u_8_strict(deserializer);
    return ED25519Res(seed: var_seed, publicKey: var_publicKey);
  }

  @protected
  ED25519SignReq sse_decode_ed_25519_sign_req(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_seed = sse_decode_list_prim_u_8_strict(deserializer);
    var var_message = sse_decode_list_prim_u_8_strict(deserializer);
    return ED25519SignReq(seed: var_seed, message: var_message);
  }

  @protected
  ED25519VerifyReq sse_decode_ed_25519_verify_req(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_sig = sse_decode_list_prim_u_8_strict(deserializer);
    var var_message = sse_decode_list_prim_u_8_strict(deserializer);
    var var_pubKey = sse_decode_list_prim_u_8_strict(deserializer);
    return ED25519VerifyReq(
        sig: var_sig, message: var_message, pubKey: var_pubKey);
  }

  @protected
  KeyDerivedRes sse_decode_key_derived_res(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_leftBits = sse_decode_list_prim_u_8_strict(deserializer);
    var var_rightBits = sse_decode_list_prim_u_8_strict(deserializer);
    return KeyDerivedRes(leftBits: var_leftBits, rightBits: var_rightBits);
  }

  @protected
  Uint8List sse_decode_list_prim_u_8_strict(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var len_ = sse_decode_i_32(deserializer);
    return deserializer.buffer.getUint8List(len_);
  }

  @protected
  int? sse_decode_opt_box_autoadd_u_8(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    if (sse_decode_bool(deserializer)) {
      return (sse_decode_box_autoadd_u_8(deserializer));
    } else {
      return null;
    }
  }

  @protected
  Uint8List? sse_decode_opt_list_prim_u_8_strict(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    if (sse_decode_bool(deserializer)) {
      return (sse_decode_list_prim_u_8_strict(deserializer));
    } else {
      return null;
    }
  }

  @protected
  P256FromSeedReq sse_decode_p_256_from_seed_req(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_seed = sse_decode_list_prim_u_8_strict(deserializer);
    return P256FromSeedReq(seed: var_seed);
  }

  @protected
  P256IdentityExport sse_decode_p_256_identity_export(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_privateKeyHash = sse_decode_list_prim_u_8_strict(deserializer);
    var var_derEncodedPublicKey = sse_decode_list_prim_u_8_strict(deserializer);
    return P256IdentityExport(
        privateKeyHash: var_privateKeyHash,
        derEncodedPublicKey: var_derEncodedPublicKey);
  }

  @protected
  P256ShareSecretReq sse_decode_p_256_share_secret_req(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_seed = sse_decode_list_prim_u_8_strict(deserializer);
    var var_publicKeyRawBytes = sse_decode_list_prim_u_8_strict(deserializer);
    return P256ShareSecretReq(
        seed: var_seed, publicKeyRawBytes: var_publicKeyRawBytes);
  }

  @protected
  P256SignWithSeedReq sse_decode_p_256_sign_with_seed_req(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_msg = sse_decode_list_prim_u_8_strict(deserializer);
    var var_seed = sse_decode_list_prim_u_8_strict(deserializer);
    return P256SignWithSeedReq(msg: var_msg, seed: var_seed);
  }

  @protected
  P256VerifyReq sse_decode_p_256_verify_req(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_messageHash = sse_decode_list_prim_u_8_strict(deserializer);
    var var_signatureBytes = sse_decode_list_prim_u_8_strict(deserializer);
    var var_publicKeyBytes = sse_decode_list_prim_u_8_strict(deserializer);
    return P256VerifyReq(
        messageHash: var_messageHash,
        signatureBytes: var_signatureBytes,
        publicKeyBytes: var_publicKeyBytes);
  }

  @protected
  PBKDFDeriveReq sse_decode_pbkdf_derive_req(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_password = sse_decode_list_prim_u_8_strict(deserializer);
    var var_salt = sse_decode_list_prim_u_8_strict(deserializer);
    var var_c = sse_decode_u_32(deserializer);
    return PBKDFDeriveReq(password: var_password, salt: var_salt, c: var_c);
  }

  @protected
  PhraseToSeedReq sse_decode_phrase_to_seed_req(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_phrase = sse_decode_String(deserializer);
    var var_password = sse_decode_String(deserializer);
    return PhraseToSeedReq(phrase: var_phrase, password: var_password);
  }

  @protected
  SchnorrFromSeedReq sse_decode_schnorr_from_seed_req(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_seed = sse_decode_list_prim_u_8_strict(deserializer);
    return SchnorrFromSeedReq(seed: var_seed);
  }

  @protected
  SchnorrIdentityExport sse_decode_schnorr_identity_export(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_privateKeyHash = sse_decode_list_prim_u_8_strict(deserializer);
    var var_publicKeyHash = sse_decode_list_prim_u_8_strict(deserializer);
    return SchnorrIdentityExport(
        privateKeyHash: var_privateKeyHash, publicKeyHash: var_publicKeyHash);
  }

  @protected
  SchnorrSignWithSeedReq sse_decode_schnorr_sign_with_seed_req(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_msg = sse_decode_list_prim_u_8_strict(deserializer);
    var var_seed = sse_decode_list_prim_u_8_strict(deserializer);
    var var_auxRand = sse_decode_opt_list_prim_u_8_strict(deserializer);
    return SchnorrSignWithSeedReq(
        msg: var_msg, seed: var_seed, auxRand: var_auxRand);
  }

  @protected
  SchnorrVerifyReq sse_decode_schnorr_verify_req(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_messageHash = sse_decode_list_prim_u_8_strict(deserializer);
    var var_signatureBytes = sse_decode_list_prim_u_8_strict(deserializer);
    var var_publicKeyBytes = sse_decode_list_prim_u_8_strict(deserializer);
    return SchnorrVerifyReq(
        messageHash: var_messageHash,
        signatureBytes: var_signatureBytes,
        publicKeyBytes: var_publicKeyBytes);
  }

  @protected
  ScriptDeriveReq sse_decode_script_derive_req(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_password = sse_decode_list_prim_u_8_strict(deserializer);
    var var_salt = sse_decode_list_prim_u_8_strict(deserializer);
    var var_n = sse_decode_u_32(deserializer);
    var var_p = sse_decode_u_32(deserializer);
    var var_r = sse_decode_u_32(deserializer);
    return ScriptDeriveReq(
        password: var_password, salt: var_salt, n: var_n, p: var_p, r: var_r);
  }

  @protected
  Secp256k1FromSeedReq sse_decode_secp_256_k_1_from_seed_req(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_seed = sse_decode_list_prim_u_8_strict(deserializer);
    return Secp256k1FromSeedReq(seed: var_seed);
  }

  @protected
  Secp256k1IdentityExport sse_decode_secp_256_k_1_identity_export(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_privateKeyHash = sse_decode_list_prim_u_8_strict(deserializer);
    var var_derEncodedPublicKey = sse_decode_list_prim_u_8_strict(deserializer);
    return Secp256k1IdentityExport(
        privateKeyHash: var_privateKeyHash,
        derEncodedPublicKey: var_derEncodedPublicKey);
  }

  @protected
  Secp256k1RecoverReq sse_decode_secp_256_k_1_recover_req(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_messagePreHashed = sse_decode_list_prim_u_8_strict(deserializer);
    var var_signatureBytes = sse_decode_list_prim_u_8_strict(deserializer);
    var var_chainId = sse_decode_opt_box_autoadd_u_8(deserializer);
    return Secp256k1RecoverReq(
        messagePreHashed: var_messagePreHashed,
        signatureBytes: var_signatureBytes,
        chainId: var_chainId);
  }

  @protected
  Secp256k1ShareSecretReq sse_decode_secp_256_k_1_share_secret_req(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_seed = sse_decode_list_prim_u_8_strict(deserializer);
    var var_publicKeyRawBytes = sse_decode_list_prim_u_8_strict(deserializer);
    return Secp256k1ShareSecretReq(
        seed: var_seed, publicKeyRawBytes: var_publicKeyRawBytes);
  }

  @protected
  Secp256k1SignWithRngReq sse_decode_secp_256_k_1_sign_with_rng_req(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_msg = sse_decode_list_prim_u_8_strict(deserializer);
    var var_privateBytes = sse_decode_list_prim_u_8_strict(deserializer);
    return Secp256k1SignWithRngReq(
        msg: var_msg, privateBytes: var_privateBytes);
  }

  @protected
  Secp256k1SignWithSeedReq sse_decode_secp_256_k_1_sign_with_seed_req(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_msg = sse_decode_list_prim_u_8_strict(deserializer);
    var var_seed = sse_decode_list_prim_u_8_strict(deserializer);
    return Secp256k1SignWithSeedReq(msg: var_msg, seed: var_seed);
  }

  @protected
  Secp256k1VerifyReq sse_decode_secp_256_k_1_verify_req(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_messageHash = sse_decode_list_prim_u_8_strict(deserializer);
    var var_signatureBytes = sse_decode_list_prim_u_8_strict(deserializer);
    var var_publicKeyBytes = sse_decode_list_prim_u_8_strict(deserializer);
    return Secp256k1VerifyReq(
        messageHash: var_messageHash,
        signatureBytes: var_signatureBytes,
        publicKeyBytes: var_publicKeyBytes);
  }

  @protected
  SeedToKeyReq sse_decode_seed_to_key_req(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_seed = sse_decode_list_prim_u_8_strict(deserializer);
    var var_path = sse_decode_String(deserializer);
    return SeedToKeyReq(seed: var_seed, path: var_path);
  }

  @protected
  SignatureFFI sse_decode_signature_ffi(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_publicKey = sse_decode_opt_list_prim_u_8_strict(deserializer);
    var var_signature = sse_decode_opt_list_prim_u_8_strict(deserializer);
    return SignatureFFI(publicKey: var_publicKey, signature: var_signature);
  }

  @protected
  int sse_decode_u_32(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return deserializer.buffer.getUint32();
  }

  @protected
  int sse_decode_u_8(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return deserializer.buffer.getUint8();
  }

  @protected
  void sse_decode_unit(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
  }

  @protected
  int sse_decode_i_32(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return deserializer.buffer.getInt32();
  }

  @protected
  void sse_encode_String(String self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_list_prim_u_8_strict(utf8.encoder.convert(self), serializer);
  }

  @protected
  void sse_encode_aes_decrypt_req(
      AesDecryptReq self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_list_prim_u_8_strict(self.key, serializer);
    sse_encode_list_prim_u_8_strict(self.iv, serializer);
    sse_encode_list_prim_u_8_strict(self.cipherText, serializer);
  }

  @protected
  void sse_encode_aes_encrypt_req(
      AesEncryptReq self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_list_prim_u_8_strict(self.key, serializer);
    sse_encode_list_prim_u_8_strict(self.iv, serializer);
    sse_encode_list_prim_u_8_strict(self.message, serializer);
  }

  @protected
  void sse_encode_bls_verify_req(BLSVerifyReq self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_list_prim_u_8_strict(self.signature, serializer);
    sse_encode_list_prim_u_8_strict(self.message, serializer);
    sse_encode_list_prim_u_8_strict(self.publicKey, serializer);
  }

  @protected
  void sse_encode_bool(bool self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    serializer.buffer.putUint8(self ? 1 : 0);
  }

  @protected
  void sse_encode_box_autoadd_aes_decrypt_req(
      AesDecryptReq self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_aes_decrypt_req(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_aes_encrypt_req(
      AesEncryptReq self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_aes_encrypt_req(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_bls_verify_req(
      BLSVerifyReq self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_bls_verify_req(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_ed_25519_from_seed_req(
      ED25519FromSeedReq self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_ed_25519_from_seed_req(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_ed_25519_sign_req(
      ED25519SignReq self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_ed_25519_sign_req(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_ed_25519_verify_req(
      ED25519VerifyReq self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_ed_25519_verify_req(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_p_256_from_seed_req(
      P256FromSeedReq self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_p_256_from_seed_req(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_p_256_share_secret_req(
      P256ShareSecretReq self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_p_256_share_secret_req(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_p_256_sign_with_seed_req(
      P256SignWithSeedReq self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_p_256_sign_with_seed_req(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_p_256_verify_req(
      P256VerifyReq self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_p_256_verify_req(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_pbkdf_derive_req(
      PBKDFDeriveReq self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_pbkdf_derive_req(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_phrase_to_seed_req(
      PhraseToSeedReq self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_phrase_to_seed_req(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_schnorr_from_seed_req(
      SchnorrFromSeedReq self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_schnorr_from_seed_req(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_schnorr_sign_with_seed_req(
      SchnorrSignWithSeedReq self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_schnorr_sign_with_seed_req(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_schnorr_verify_req(
      SchnorrVerifyReq self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_schnorr_verify_req(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_script_derive_req(
      ScriptDeriveReq self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_script_derive_req(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_secp_256_k_1_from_seed_req(
      Secp256k1FromSeedReq self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_secp_256_k_1_from_seed_req(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_secp_256_k_1_recover_req(
      Secp256k1RecoverReq self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_secp_256_k_1_recover_req(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_secp_256_k_1_share_secret_req(
      Secp256k1ShareSecretReq self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_secp_256_k_1_share_secret_req(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_secp_256_k_1_sign_with_rng_req(
      Secp256k1SignWithRngReq self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_secp_256_k_1_sign_with_rng_req(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_secp_256_k_1_sign_with_seed_req(
      Secp256k1SignWithSeedReq self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_secp_256_k_1_sign_with_seed_req(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_secp_256_k_1_verify_req(
      Secp256k1VerifyReq self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_secp_256_k_1_verify_req(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_seed_to_key_req(
      SeedToKeyReq self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_seed_to_key_req(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_u_8(int self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_u_8(self, serializer);
  }

  @protected
  void sse_encode_ed_25519_from_seed_req(
      ED25519FromSeedReq self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_list_prim_u_8_strict(self.seed, serializer);
  }

  @protected
  void sse_encode_ed_25519_res(ED25519Res self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_list_prim_u_8_strict(self.seed, serializer);
    sse_encode_list_prim_u_8_strict(self.publicKey, serializer);
  }

  @protected
  void sse_encode_ed_25519_sign_req(
      ED25519SignReq self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_list_prim_u_8_strict(self.seed, serializer);
    sse_encode_list_prim_u_8_strict(self.message, serializer);
  }

  @protected
  void sse_encode_ed_25519_verify_req(
      ED25519VerifyReq self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_list_prim_u_8_strict(self.sig, serializer);
    sse_encode_list_prim_u_8_strict(self.message, serializer);
    sse_encode_list_prim_u_8_strict(self.pubKey, serializer);
  }

  @protected
  void sse_encode_key_derived_res(
      KeyDerivedRes self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_list_prim_u_8_strict(self.leftBits, serializer);
    sse_encode_list_prim_u_8_strict(self.rightBits, serializer);
  }

  @protected
  void sse_encode_list_prim_u_8_strict(
      Uint8List self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.length, serializer);
    serializer.buffer.putUint8List(self);
  }

  @protected
  void sse_encode_opt_box_autoadd_u_8(int? self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    sse_encode_bool(self != null, serializer);
    if (self != null) {
      sse_encode_box_autoadd_u_8(self, serializer);
    }
  }

  @protected
  void sse_encode_opt_list_prim_u_8_strict(
      Uint8List? self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    sse_encode_bool(self != null, serializer);
    if (self != null) {
      sse_encode_list_prim_u_8_strict(self, serializer);
    }
  }

  @protected
  void sse_encode_p_256_from_seed_req(
      P256FromSeedReq self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_list_prim_u_8_strict(self.seed, serializer);
  }

  @protected
  void sse_encode_p_256_identity_export(
      P256IdentityExport self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_list_prim_u_8_strict(self.privateKeyHash, serializer);
    sse_encode_list_prim_u_8_strict(self.derEncodedPublicKey, serializer);
  }

  @protected
  void sse_encode_p_256_share_secret_req(
      P256ShareSecretReq self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_list_prim_u_8_strict(self.seed, serializer);
    sse_encode_list_prim_u_8_strict(self.publicKeyRawBytes, serializer);
  }

  @protected
  void sse_encode_p_256_sign_with_seed_req(
      P256SignWithSeedReq self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_list_prim_u_8_strict(self.msg, serializer);
    sse_encode_list_prim_u_8_strict(self.seed, serializer);
  }

  @protected
  void sse_encode_p_256_verify_req(
      P256VerifyReq self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_list_prim_u_8_strict(self.messageHash, serializer);
    sse_encode_list_prim_u_8_strict(self.signatureBytes, serializer);
    sse_encode_list_prim_u_8_strict(self.publicKeyBytes, serializer);
  }

  @protected
  void sse_encode_pbkdf_derive_req(
      PBKDFDeriveReq self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_list_prim_u_8_strict(self.password, serializer);
    sse_encode_list_prim_u_8_strict(self.salt, serializer);
    sse_encode_u_32(self.c, serializer);
  }

  @protected
  void sse_encode_phrase_to_seed_req(
      PhraseToSeedReq self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_String(self.phrase, serializer);
    sse_encode_String(self.password, serializer);
  }

  @protected
  void sse_encode_schnorr_from_seed_req(
      SchnorrFromSeedReq self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_list_prim_u_8_strict(self.seed, serializer);
  }

  @protected
  void sse_encode_schnorr_identity_export(
      SchnorrIdentityExport self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_list_prim_u_8_strict(self.privateKeyHash, serializer);
    sse_encode_list_prim_u_8_strict(self.publicKeyHash, serializer);
  }

  @protected
  void sse_encode_schnorr_sign_with_seed_req(
      SchnorrSignWithSeedReq self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_list_prim_u_8_strict(self.msg, serializer);
    sse_encode_list_prim_u_8_strict(self.seed, serializer);
    sse_encode_opt_list_prim_u_8_strict(self.auxRand, serializer);
  }

  @protected
  void sse_encode_schnorr_verify_req(
      SchnorrVerifyReq self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_list_prim_u_8_strict(self.messageHash, serializer);
    sse_encode_list_prim_u_8_strict(self.signatureBytes, serializer);
    sse_encode_list_prim_u_8_strict(self.publicKeyBytes, serializer);
  }

  @protected
  void sse_encode_script_derive_req(
      ScriptDeriveReq self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_list_prim_u_8_strict(self.password, serializer);
    sse_encode_list_prim_u_8_strict(self.salt, serializer);
    sse_encode_u_32(self.n, serializer);
    sse_encode_u_32(self.p, serializer);
    sse_encode_u_32(self.r, serializer);
  }

  @protected
  void sse_encode_secp_256_k_1_from_seed_req(
      Secp256k1FromSeedReq self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_list_prim_u_8_strict(self.seed, serializer);
  }

  @protected
  void sse_encode_secp_256_k_1_identity_export(
      Secp256k1IdentityExport self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_list_prim_u_8_strict(self.privateKeyHash, serializer);
    sse_encode_list_prim_u_8_strict(self.derEncodedPublicKey, serializer);
  }

  @protected
  void sse_encode_secp_256_k_1_recover_req(
      Secp256k1RecoverReq self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_list_prim_u_8_strict(self.messagePreHashed, serializer);
    sse_encode_list_prim_u_8_strict(self.signatureBytes, serializer);
    sse_encode_opt_box_autoadd_u_8(self.chainId, serializer);
  }

  @protected
  void sse_encode_secp_256_k_1_share_secret_req(
      Secp256k1ShareSecretReq self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_list_prim_u_8_strict(self.seed, serializer);
    sse_encode_list_prim_u_8_strict(self.publicKeyRawBytes, serializer);
  }

  @protected
  void sse_encode_secp_256_k_1_sign_with_rng_req(
      Secp256k1SignWithRngReq self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_list_prim_u_8_strict(self.msg, serializer);
    sse_encode_list_prim_u_8_strict(self.privateBytes, serializer);
  }

  @protected
  void sse_encode_secp_256_k_1_sign_with_seed_req(
      Secp256k1SignWithSeedReq self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_list_prim_u_8_strict(self.msg, serializer);
    sse_encode_list_prim_u_8_strict(self.seed, serializer);
  }

  @protected
  void sse_encode_secp_256_k_1_verify_req(
      Secp256k1VerifyReq self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_list_prim_u_8_strict(self.messageHash, serializer);
    sse_encode_list_prim_u_8_strict(self.signatureBytes, serializer);
    sse_encode_list_prim_u_8_strict(self.publicKeyBytes, serializer);
  }

  @protected
  void sse_encode_seed_to_key_req(SeedToKeyReq self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_list_prim_u_8_strict(self.seed, serializer);
    sse_encode_String(self.path, serializer);
  }

  @protected
  void sse_encode_signature_ffi(SignatureFFI self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_opt_list_prim_u_8_strict(self.publicKey, serializer);
    sse_encode_opt_list_prim_u_8_strict(self.signature, serializer);
  }

  @protected
  void sse_encode_u_32(int self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    serializer.buffer.putUint32(self);
  }

  @protected
  void sse_encode_u_8(int self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    serializer.buffer.putUint8(self);
  }

  @protected
  void sse_encode_unit(void self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
  }

  @protected
  void sse_encode_i_32(int self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    serializer.buffer.putInt32(self);
  }
}

// This file is automatically generated, so please do not edit it.
// Generated by `flutter_rust_bridge`@ 2.0.0.

// ignore_for_file: unused_import, unused_element, unnecessary_import, duplicate_ignore, invalid_use_of_internal_member, annotate_overrides, non_constant_identifier_names, curly_braces_in_flow_control_structures, prefer_const_literals_to_create_immutables, unused_field

import 'api.dart';
import 'bdk/blockchain.dart';
import 'bdk/types.dart';
import 'bdk/wallet.dart';
import 'dart:async';
import 'dart:convert';
import 'frb_generated.dart';
import 'frb_generated.io.dart'
    if (dart.library.js_interop) 'frb_generated.web.dart';
import 'lib.dart';
import 'p256.dart';
import 'package:flutter_rust_bridge/flutter_rust_bridge_for_generated.dart';
import 'schnorr.dart';
import 'secp256k1.dart';
import 'types.dart';

/// Main entrypoint of the Rust API
class RustLib extends BaseEntrypoint<RustLibApi, RustLibApiImpl, RustLibWire> {
  @internal
  static final instance = RustLib._();

  RustLib._();

  /// Initialize flutter_rust_bridge
  static Future<void> init({
    RustLibApi? api,
    BaseHandler? handler,
    ExternalLibrary? externalLibrary,
  }) async {
    await instance.initImpl(
      api: api,
      handler: handler,
      externalLibrary: externalLibrary,
    );
  }

  /// Dispose flutter_rust_bridge
  ///
  /// The call to this function is optional, since flutter_rust_bridge (and everything else)
  /// is automatically disposed when the app stops.
  static void dispose() => instance.disposeImpl();

  @override
  ApiImplConstructor<RustLibApiImpl, RustLibWire> get apiImplConstructor =>
      RustLibApiImpl.new;

  @override
  WireConstructor<RustLibWire> get wireConstructor =>
      RustLibWire.fromExternalLibrary;

  @override
  Future<void> executeRustInitializers() async {}

  @override
  ExternalLibraryLoaderConfig get defaultExternalLibraryLoaderConfig =>
      kDefaultExternalLibraryLoaderConfig;

  @override
  String get codegenVersion => '2.0.0';

  @override
  int get rustContentHash => 885740095;

  static const kDefaultExternalLibraryLoaderConfig =
      ExternalLibraryLoaderConfig(
    stem: 'agent_dart',
    ioDirectory: 'native/agent_dart/target/release/',
    webPrefix: 'pkg/',
  );
}

abstract class RustLibApi extends BaseApi {
  Future<Uint8List> crateApiAes128CtrDecrypt({required AesDecryptReq req});

  Future<Uint8List> crateApiAes128CtrEncrypt({required AesEncryptReq req});

  Future<Uint8List> crateApiAes256CbcDecrypt({required AesDecryptReq req});

  Future<Uint8List> crateApiAes256CbcEncrypt({required AesEncryptReq req});

  Future<Uint8List> crateApiAes256GcmDecrypt({required AesDecryptReq req});

  Future<Uint8List> crateApiAes256GcmEncrypt({required AesEncryptReq req});

  Future<String> crateApiApiAddressFromScript(
      {required Script script, required Network network});

  Future<Network> crateApiApiAddressNetwork({required String address});

  Future<Script> crateApiApiAddressToScriptPubkey({required String address});

  Future<String> crateApiApiAsPublic({required String secret});

  Future<Uint8List> crateApiApiAsSecretBytes({required String secret});

  Future<String> crateApiApiAsString({required BdkDescriptor descriptor});

  Future<String> crateApiApiAsStringPrivate(
      {required BdkDescriptor descriptor});

  Future<String> crateApiApiBip322SignSegwit(
      {required List<int> secret, required String message});

  Future<String> crateApiApiBip322SignTaproot(
      {required List<int> secret, required String message});

  Future<String> crateApiApiBroadcast(
      {required String tx, required BlockchainInstance blockchain});

  Future<BdkTxBuilderResult> crateApiApiBumpFeeTxBuilderFinish(
      {required String txid,
      required double feeRate,
      String? allowShrinking,
      required WalletInstance wallet,
      required bool enableRbf,
      required bool keepChange,
      int? nSequence});

  Future<bool> crateApiApiCacheAddress(
      {required WalletInstance wallet, required int cacheSize});

  Future<String> crateApiApiCombinePsbt(
      {required String psbtStr, required String other});

  Future<String> crateApiApiCreateAddress({required String address});

  Future<BlockchainInstance> crateApiApiCreateBlockchain(
      {required BlockchainConfig config});

  Future<String> crateApiApiCreateDerivationPath({required String path});

  Future<String> crateApiApiCreateDerivedDescriptorSecret(
      {required Network network,
      required String mnemonic,
      required String path,
      String? password});

  Future<BdkDescriptor> crateApiApiCreateDescriptor(
      {required String descriptor, required Network network});

  Future<String> crateApiApiCreateDescriptorPublic(
      {String? xpub, required String path, required bool derive});

  Future<String> crateApiApiCreateDescriptorSecret(
      {required Network network, required String mnemonic, String? password});

  Future<Script> crateApiApiCreateScript({required List<int> rawOutputScript});

  Future<String> crateApiApiCreateTransaction({required List<int> tx});

  Future<WalletInstance> crateApiApiCreateWallet(
      {required BdkDescriptor descriptor,
      BdkDescriptor? changeDescriptor,
      required Network network,
      required DatabaseConfig databaseConfig});

  Future<AddressInfo> crateApiApiDeriveAddressAt(
      {required BdkDescriptor descriptor,
      required int index,
      required Network network});

  Future<String> crateApiApiDeriveDescriptorSecret(
      {required String secret, required String path});

  Future<String> crateApiApiDescriptorPublicFromString(
      {required String publicKey});

  Future<String> crateApiApiDescriptorSecretFromString(
      {required String secret});

  Future<double> crateApiApiEstimateFee(
      {required BigInt target, required BlockchainInstance blockchain});

  Future<String> crateApiApiExtendDescriptorSecret(
      {required String secret, required String path});

  Future<String> crateApiApiExtractTx({required String psbtStr});

  Future<String> crateApiApiGenerateSeedFromEntropy(
      {required List<int> entropy});

  Future<String> crateApiApiGenerateSeedFromString({required String mnemonic});

  Future<String> crateApiApiGenerateSeedFromWordCount(
      {required WordCount wordCount});

  Future<AddressInfo> crateApiApiGetAddress(
      {required WalletInstance wallet, required AddressIndex addressIndex});

  Future<String> crateApiApiGetAddressType({required String address});

  Future<Balance> crateApiApiGetBalance({required WalletInstance wallet});

  Future<String> crateApiApiGetBlockchainHash(
      {required int blockchainHeight, required BlockchainInstance blockchain});

  Future<int> crateApiApiGetHeight({required BlockchainInstance blockchain});

  Future<List<TxOut>> crateApiApiGetInputs({required String psbtStr});

  Future<AddressInfo> crateApiApiGetInternalAddress(
      {required WalletInstance wallet, required AddressIndex addressIndex});

  Future<String> crateApiApiGetPubFromSecretBytes({required List<int> bytes});

  Future<List<TransactionDetails>> crateApiApiGetTransactions(
      {required WalletInstance wallet, required bool includeRaw});

  Future<String> crateApiApiGetTx(
      {required String tx, required BlockchainInstance blockchain});

  Future<BdkDescriptor> crateApiApiImportSingleWif(
      {required String wif,
      required String addressType,
      required Network network});

  Future<List<TxIn>> crateApiApiInput({required String tx});

  Future<bool> crateApiApiIsCoinBase({required String tx});

  Future<bool> crateApiApiIsExplicitlyRbf({required String tx});

  Future<bool> crateApiApiIsLockTimeEnabled({required String tx});

  Future<String> crateApiApiJsonSerialize({required String psbtStr});

  Future<List<LocalUtxo>> crateApiApiListUnspent(
      {required WalletInstance wallet});

  Future<List<LocalUtxo>> crateApiApiListUnspentOutputs(
      {required WalletInstance wallet});

  Future<int> crateApiApiLockTime({required String tx});

  Future<String> crateApiApiMasterFinterprint({required String xpub});

  Future<BdkDescriptor> crateApiApiNewBip44Descriptor(
      {required KeychainKind keyChainKind,
      required String secretKey,
      required Network network});

  Future<BdkDescriptor> crateApiApiNewBip44Public(
      {required KeychainKind keyChainKind,
      required String publicKey,
      required Network network,
      required String fingerprint});

  Future<BdkDescriptor> crateApiApiNewBip44TrDescriptor(
      {required KeychainKind keyChainKind,
      required String secretKey,
      required Network network});

  Future<BdkDescriptor> crateApiApiNewBip44TrPublic(
      {required KeychainKind keyChainKind,
      required String publicKey,
      required Network network,
      required String fingerprint});

  Future<BdkDescriptor> crateApiApiNewBip49Descriptor(
      {required KeychainKind keyChainKind,
      required String secretKey,
      required Network network});

  Future<BdkDescriptor> crateApiApiNewBip49Public(
      {required KeychainKind keyChainKind,
      required String publicKey,
      required Network network,
      required String fingerprint});

  Future<BdkDescriptor> crateApiApiNewBip84Descriptor(
      {required KeychainKind keyChainKind,
      required String secretKey,
      required Network network});

  Future<BdkDescriptor> crateApiApiNewBip84Public(
      {required KeychainKind keyChainKind,
      required String publicKey,
      required Network network,
      required String fingerprint});

  Future<BdkDescriptor> crateApiApiNewBip86Descriptor(
      {required KeychainKind keyChainKind,
      required String secretKey,
      required Network network});

  Future<BdkDescriptor> crateApiApiNewBip86Public(
      {required KeychainKind keyChainKind,
      required String publicKey,
      required Network network,
      required String fingerprint});

  Future<List<TxOut>> crateApiApiOutput({required String tx});

  Future<Payload> crateApiApiPayload({required String address});

  Future<BigInt?> crateApiApiPsbtFeeAmount({required String psbtStr});

  Future<double?> crateApiApiPsbtFeeRate({required String psbtStr});

  Future<String> crateApiApiPsbtTxid({required String psbtStr});

  Future<String> crateApiApiSerializePsbt({required String psbtStr});

  Future<Uint8List> crateApiApiSerializeTx({required String tx});

  Future<String?> crateApiApiSign(
      {required WalletInstance wallet,
      required String psbtStr,
      SignOptions? signOptions});

  Future<BigInt> crateApiApiSize({required String tx});

  Future<String> crateApiApiToPublicString({required String xpub});

  Future<BdkTxBuilderResult> crateApiApiTxBuilderFinish(
      {required WalletInstance wallet,
      required List<ScriptAmount> recipients,
      required List<TxBytes> txs,
      required List<OutPoint> unspendable,
      required List<ForeignUtxo> foreignUtxos,
      required ChangeSpendPolicy changePolicy,
      required bool manuallySelectedOnly,
      double? feeRate,
      BigInt? feeAbsolute,
      required bool drainWallet,
      Script? drainTo,
      RbfValue? rbf,
      required List<int> data,
      bool? shuffleUtxo});

  Future<BigInt> crateApiApiTxCalFeeFinish(
      {required WalletInstance wallet,
      required List<ScriptAmount> recipients,
      required List<TxBytes> txs,
      required List<OutPoint> unspendable,
      required List<ForeignUtxo> foreignUtxos,
      required ChangeSpendPolicy changePolicy,
      required bool manuallySelectedOnly,
      double? feeRate,
      BigInt? feeAbsolute,
      required bool drainWallet,
      Script? drainTo,
      RbfValue? rbf,
      required List<int> data,
      bool? shuffleUtxo});

  Future<String> crateApiApiTxTxid({required String tx});

  Future<int> crateApiApiVersion({required String tx});

  Future<BigInt> crateApiApiVsize({required String tx});

  Future<Network> crateApiApiWalletNetwork({required WalletInstance wallet});

  Future<BigInt> crateApiApiWeight({required String tx});

  Future<bool> crateApiBlsInit();

  Future<bool> crateApiBlsVerify({required BLSVerifyReq req});

  Future<ED25519Res> crateApiEd25519FromSeed({required ED25519FromSeedReq req});

  Future<Uint8List> crateApiEd25519Sign({required ED25519SignReq req});

  Future<bool> crateApiEd25519Verify({required ED25519VerifyReq req});

  Future<String> crateApiHexBytesToWif(
      {required String hex, required Network network});

  Future<Uint8List> crateApiMnemonicPhraseToSeed(
      {required PhraseToSeedReq req});

  Future<Uint8List> crateApiMnemonicSeedToKey({required SeedToKeyReq req});

  Future<P256IdentityExport> crateApiP256FromSeed(
      {required P256FromSeedReq req});

  Future<Uint8List> crateApiP256GetSharedSecret(
      {required P256ShareSecretReq req});

  Future<SignatureFFI> crateApiP256Sign({required P256SignWithSeedReq req});

  Future<bool> crateApiP256Verify({required P256VerifyReq req});

  Future<KeyDerivedRes> crateApiPbkdf2DeriveKey({required PBKDFDeriveReq req});

  Future<SchnorrIdentityExport> crateApiSchnorrFromSeed(
      {required SchnorrFromSeedReq req});

  Future<SignatureFFI> crateApiSchnorrSign(
      {required SchnorrSignWithSeedReq req});

  Future<bool> crateApiSchnorrVerify({required SchnorrVerifyReq req});

  Future<KeyDerivedRes> crateApiScryptDeriveKey({required ScriptDeriveReq req});

  Future<Secp256k1IdentityExport> crateApiSecp256K1FromSeed(
      {required Secp256k1FromSeedReq req});

  Future<Uint8List> crateApiSecp256K1GetSharedSecret(
      {required Secp256k1ShareSecretReq req});

  Future<Uint8List> crateApiSecp256K1Recover(
      {required Secp256k1RecoverReq req});

  Future<SignatureFFI> crateApiSecp256K1Sign(
      {required Secp256k1SignWithSeedReq req});

  Future<SignatureFFI> crateApiSecp256K1SignRecoverable(
      {required Secp256k1SignWithSeedReq req});

  Future<SignatureFFI> crateApiSecp256K1SignWithRng(
      {required Secp256k1SignWithRngReq req});

  Future<bool> crateApiSecp256K1Verify({required Secp256k1VerifyReq req});

  RustArcIncrementStrongCountFnType
      get rust_arc_increment_strong_count_BdkDescriptor;

  RustArcDecrementStrongCountFnType
      get rust_arc_decrement_strong_count_BdkDescriptor;

  CrossPlatformFinalizerArg
      get rust_arc_decrement_strong_count_BdkDescriptorPtr;

  RustArcIncrementStrongCountFnType
      get rust_arc_increment_strong_count_BlockchainInstance;

  RustArcDecrementStrongCountFnType
      get rust_arc_decrement_strong_count_BlockchainInstance;

  CrossPlatformFinalizerArg
      get rust_arc_decrement_strong_count_BlockchainInstancePtr;

  RustArcIncrementStrongCountFnType
      get rust_arc_increment_strong_count_WalletInstance;

  RustArcDecrementStrongCountFnType
      get rust_arc_decrement_strong_count_WalletInstance;

  CrossPlatformFinalizerArg
      get rust_arc_decrement_strong_count_WalletInstancePtr;
}

class RustLibApiImpl extends RustLibApiImplPlatform implements RustLibApi {
  RustLibApiImpl({
    required super.handler,
    required super.wire,
    required super.generalizedFrbRustBinding,
    required super.portManager,
  });

  @override
  Future<Uint8List> crateApiAes128CtrDecrypt({required AesDecryptReq req}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_box_autoadd_aes_decrypt_req(req, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 1, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_list_prim_u_8_strict,
        decodeErrorData: null,
      ),
      constMeta: kCrateApiAes128CtrDecryptConstMeta,
      argValues: [req],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiAes128CtrDecryptConstMeta => const TaskConstMeta(
        debugName: "aes_128_ctr_decrypt",
        argNames: ["req"],
      );

  @override
  Future<Uint8List> crateApiAes128CtrEncrypt({required AesEncryptReq req}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_box_autoadd_aes_encrypt_req(req, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 2, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_list_prim_u_8_strict,
        decodeErrorData: null,
      ),
      constMeta: kCrateApiAes128CtrEncryptConstMeta,
      argValues: [req],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiAes128CtrEncryptConstMeta => const TaskConstMeta(
        debugName: "aes_128_ctr_encrypt",
        argNames: ["req"],
      );

  @override
  Future<Uint8List> crateApiAes256CbcDecrypt({required AesDecryptReq req}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_box_autoadd_aes_decrypt_req(req, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 3, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_list_prim_u_8_strict,
        decodeErrorData: null,
      ),
      constMeta: kCrateApiAes256CbcDecryptConstMeta,
      argValues: [req],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiAes256CbcDecryptConstMeta => const TaskConstMeta(
        debugName: "aes_256_cbc_decrypt",
        argNames: ["req"],
      );

  @override
  Future<Uint8List> crateApiAes256CbcEncrypt({required AesEncryptReq req}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_box_autoadd_aes_encrypt_req(req, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 4, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_list_prim_u_8_strict,
        decodeErrorData: null,
      ),
      constMeta: kCrateApiAes256CbcEncryptConstMeta,
      argValues: [req],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiAes256CbcEncryptConstMeta => const TaskConstMeta(
        debugName: "aes_256_cbc_encrypt",
        argNames: ["req"],
      );

  @override
  Future<Uint8List> crateApiAes256GcmDecrypt({required AesDecryptReq req}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_box_autoadd_aes_decrypt_req(req, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 5, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_list_prim_u_8_strict,
        decodeErrorData: null,
      ),
      constMeta: kCrateApiAes256GcmDecryptConstMeta,
      argValues: [req],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiAes256GcmDecryptConstMeta => const TaskConstMeta(
        debugName: "aes_256_gcm_decrypt",
        argNames: ["req"],
      );

  @override
  Future<Uint8List> crateApiAes256GcmEncrypt({required AesEncryptReq req}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_box_autoadd_aes_encrypt_req(req, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 6, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_list_prim_u_8_strict,
        decodeErrorData: null,
      ),
      constMeta: kCrateApiAes256GcmEncryptConstMeta,
      argValues: [req],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiAes256GcmEncryptConstMeta => const TaskConstMeta(
        debugName: "aes_256_gcm_encrypt",
        argNames: ["req"],
      );

  @override
  Future<String> crateApiApiAddressFromScript(
      {required Script script, required Network network}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_box_autoadd_script(script, serializer);
        sse_encode_network(network, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 7, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_String,
        decodeErrorData: sse_decode_AnyhowException,
      ),
      constMeta: kCrateApiApiAddressFromScriptConstMeta,
      argValues: [script, network],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiApiAddressFromScriptConstMeta =>
      const TaskConstMeta(
        debugName: "api_address_from_script",
        argNames: ["script", "network"],
      );

  @override
  Future<Network> crateApiApiAddressNetwork({required String address}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_String(address, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 8, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_network,
        decodeErrorData: sse_decode_AnyhowException,
      ),
      constMeta: kCrateApiApiAddressNetworkConstMeta,
      argValues: [address],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiApiAddressNetworkConstMeta => const TaskConstMeta(
        debugName: "api_address_network",
        argNames: ["address"],
      );

  @override
  Future<Script> crateApiApiAddressToScriptPubkey({required String address}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_String(address, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 9, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_script,
        decodeErrorData: sse_decode_AnyhowException,
      ),
      constMeta: kCrateApiApiAddressToScriptPubkeyConstMeta,
      argValues: [address],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiApiAddressToScriptPubkeyConstMeta =>
      const TaskConstMeta(
        debugName: "api_address_to_script_pubkey",
        argNames: ["address"],
      );

  @override
  Future<String> crateApiApiAsPublic({required String secret}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_String(secret, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 10, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_String,
        decodeErrorData: sse_decode_AnyhowException,
      ),
      constMeta: kCrateApiApiAsPublicConstMeta,
      argValues: [secret],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiApiAsPublicConstMeta => const TaskConstMeta(
        debugName: "api_as_public",
        argNames: ["secret"],
      );

  @override
  Future<Uint8List> crateApiApiAsSecretBytes({required String secret}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_String(secret, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 11, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_list_prim_u_8_strict,
        decodeErrorData: sse_decode_AnyhowException,
      ),
      constMeta: kCrateApiApiAsSecretBytesConstMeta,
      argValues: [secret],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiApiAsSecretBytesConstMeta => const TaskConstMeta(
        debugName: "api_as_secret_bytes",
        argNames: ["secret"],
      );

  @override
  Future<String> crateApiApiAsString({required BdkDescriptor descriptor}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_RustOpaque_BdkDescriptor(descriptor, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 12, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_String,
        decodeErrorData: null,
      ),
      constMeta: kCrateApiApiAsStringConstMeta,
      argValues: [descriptor],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiApiAsStringConstMeta => const TaskConstMeta(
        debugName: "api_as_string",
        argNames: ["descriptor"],
      );

  @override
  Future<String> crateApiApiAsStringPrivate(
      {required BdkDescriptor descriptor}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_RustOpaque_BdkDescriptor(descriptor, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 13, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_String,
        decodeErrorData: null,
      ),
      constMeta: kCrateApiApiAsStringPrivateConstMeta,
      argValues: [descriptor],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiApiAsStringPrivateConstMeta => const TaskConstMeta(
        debugName: "api_as_string_private",
        argNames: ["descriptor"],
      );

  @override
  Future<String> crateApiApiBip322SignSegwit(
      {required List<int> secret, required String message}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_list_prim_u_8_loose(secret, serializer);
        sse_encode_String(message, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 14, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_String,
        decodeErrorData: null,
      ),
      constMeta: kCrateApiApiBip322SignSegwitConstMeta,
      argValues: [secret, message],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiApiBip322SignSegwitConstMeta =>
      const TaskConstMeta(
        debugName: "api_bip322_sign_segwit",
        argNames: ["secret", "message"],
      );

  @override
  Future<String> crateApiApiBip322SignTaproot(
      {required List<int> secret, required String message}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_list_prim_u_8_loose(secret, serializer);
        sse_encode_String(message, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 15, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_String,
        decodeErrorData: null,
      ),
      constMeta: kCrateApiApiBip322SignTaprootConstMeta,
      argValues: [secret, message],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiApiBip322SignTaprootConstMeta =>
      const TaskConstMeta(
        debugName: "api_bip322_sign_taproot",
        argNames: ["secret", "message"],
      );

  @override
  Future<String> crateApiApiBroadcast(
      {required String tx, required BlockchainInstance blockchain}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_String(tx, serializer);
        sse_encode_RustOpaque_BlockchainInstance(blockchain, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 16, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_String,
        decodeErrorData: sse_decode_AnyhowException,
      ),
      constMeta: kCrateApiApiBroadcastConstMeta,
      argValues: [tx, blockchain],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiApiBroadcastConstMeta => const TaskConstMeta(
        debugName: "api_broadcast",
        argNames: ["tx", "blockchain"],
      );

  @override
  Future<BdkTxBuilderResult> crateApiApiBumpFeeTxBuilderFinish(
      {required String txid,
      required double feeRate,
      String? allowShrinking,
      required WalletInstance wallet,
      required bool enableRbf,
      required bool keepChange,
      int? nSequence}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_String(txid, serializer);
        sse_encode_f_32(feeRate, serializer);
        sse_encode_opt_String(allowShrinking, serializer);
        sse_encode_RustOpaque_WalletInstance(wallet, serializer);
        sse_encode_bool(enableRbf, serializer);
        sse_encode_bool(keepChange, serializer);
        sse_encode_opt_box_autoadd_u_32(nSequence, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 17, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_bdk_tx_builder_result,
        decodeErrorData: sse_decode_AnyhowException,
      ),
      constMeta: kCrateApiApiBumpFeeTxBuilderFinishConstMeta,
      argValues: [
        txid,
        feeRate,
        allowShrinking,
        wallet,
        enableRbf,
        keepChange,
        nSequence
      ],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiApiBumpFeeTxBuilderFinishConstMeta =>
      const TaskConstMeta(
        debugName: "api_bump_fee_tx_builder_finish",
        argNames: [
          "txid",
          "feeRate",
          "allowShrinking",
          "wallet",
          "enableRbf",
          "keepChange",
          "nSequence"
        ],
      );

  @override
  Future<bool> crateApiApiCacheAddress(
      {required WalletInstance wallet, required int cacheSize}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_RustOpaque_WalletInstance(wallet, serializer);
        sse_encode_u_32(cacheSize, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 18, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_bool,
        decodeErrorData: sse_decode_AnyhowException,
      ),
      constMeta: kCrateApiApiCacheAddressConstMeta,
      argValues: [wallet, cacheSize],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiApiCacheAddressConstMeta => const TaskConstMeta(
        debugName: "api_cache_address",
        argNames: ["wallet", "cacheSize"],
      );

  @override
  Future<String> crateApiApiCombinePsbt(
      {required String psbtStr, required String other}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_String(psbtStr, serializer);
        sse_encode_String(other, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 19, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_String,
        decodeErrorData: sse_decode_AnyhowException,
      ),
      constMeta: kCrateApiApiCombinePsbtConstMeta,
      argValues: [psbtStr, other],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiApiCombinePsbtConstMeta => const TaskConstMeta(
        debugName: "api_combine_psbt",
        argNames: ["psbtStr", "other"],
      );

  @override
  Future<String> crateApiApiCreateAddress({required String address}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_String(address, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 20, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_String,
        decodeErrorData: sse_decode_AnyhowException,
      ),
      constMeta: kCrateApiApiCreateAddressConstMeta,
      argValues: [address],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiApiCreateAddressConstMeta => const TaskConstMeta(
        debugName: "api_create_address",
        argNames: ["address"],
      );

  @override
  Future<BlockchainInstance> crateApiApiCreateBlockchain(
      {required BlockchainConfig config}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_box_autoadd_blockchain_config(config, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 21, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_RustOpaque_BlockchainInstance,
        decodeErrorData: sse_decode_AnyhowException,
      ),
      constMeta: kCrateApiApiCreateBlockchainConstMeta,
      argValues: [config],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiApiCreateBlockchainConstMeta =>
      const TaskConstMeta(
        debugName: "api_create_blockchain",
        argNames: ["config"],
      );

  @override
  Future<String> crateApiApiCreateDerivationPath({required String path}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_String(path, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 22, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_String,
        decodeErrorData: sse_decode_AnyhowException,
      ),
      constMeta: kCrateApiApiCreateDerivationPathConstMeta,
      argValues: [path],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiApiCreateDerivationPathConstMeta =>
      const TaskConstMeta(
        debugName: "api_create_derivation_path",
        argNames: ["path"],
      );

  @override
  Future<String> crateApiApiCreateDerivedDescriptorSecret(
      {required Network network,
      required String mnemonic,
      required String path,
      String? password}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_network(network, serializer);
        sse_encode_String(mnemonic, serializer);
        sse_encode_String(path, serializer);
        sse_encode_opt_String(password, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 23, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_String,
        decodeErrorData: sse_decode_AnyhowException,
      ),
      constMeta: kCrateApiApiCreateDerivedDescriptorSecretConstMeta,
      argValues: [network, mnemonic, path, password],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiApiCreateDerivedDescriptorSecretConstMeta =>
      const TaskConstMeta(
        debugName: "api_create_derived_descriptor_secret",
        argNames: ["network", "mnemonic", "path", "password"],
      );

  @override
  Future<BdkDescriptor> crateApiApiCreateDescriptor(
      {required String descriptor, required Network network}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_String(descriptor, serializer);
        sse_encode_network(network, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 24, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_RustOpaque_BdkDescriptor,
        decodeErrorData: sse_decode_AnyhowException,
      ),
      constMeta: kCrateApiApiCreateDescriptorConstMeta,
      argValues: [descriptor, network],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiApiCreateDescriptorConstMeta =>
      const TaskConstMeta(
        debugName: "api_create_descriptor",
        argNames: ["descriptor", "network"],
      );

  @override
  Future<String> crateApiApiCreateDescriptorPublic(
      {String? xpub, required String path, required bool derive}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_opt_String(xpub, serializer);
        sse_encode_String(path, serializer);
        sse_encode_bool(derive, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 25, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_String,
        decodeErrorData: sse_decode_AnyhowException,
      ),
      constMeta: kCrateApiApiCreateDescriptorPublicConstMeta,
      argValues: [xpub, path, derive],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiApiCreateDescriptorPublicConstMeta =>
      const TaskConstMeta(
        debugName: "api_create_descriptor_public",
        argNames: ["xpub", "path", "derive"],
      );

  @override
  Future<String> crateApiApiCreateDescriptorSecret(
      {required Network network, required String mnemonic, String? password}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_network(network, serializer);
        sse_encode_String(mnemonic, serializer);
        sse_encode_opt_String(password, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 26, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_String,
        decodeErrorData: sse_decode_AnyhowException,
      ),
      constMeta: kCrateApiApiCreateDescriptorSecretConstMeta,
      argValues: [network, mnemonic, password],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiApiCreateDescriptorSecretConstMeta =>
      const TaskConstMeta(
        debugName: "api_create_descriptor_secret",
        argNames: ["network", "mnemonic", "password"],
      );

  @override
  Future<Script> crateApiApiCreateScript({required List<int> rawOutputScript}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_list_prim_u_8_loose(rawOutputScript, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 27, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_script,
        decodeErrorData: sse_decode_AnyhowException,
      ),
      constMeta: kCrateApiApiCreateScriptConstMeta,
      argValues: [rawOutputScript],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiApiCreateScriptConstMeta => const TaskConstMeta(
        debugName: "api_create_script",
        argNames: ["rawOutputScript"],
      );

  @override
  Future<String> crateApiApiCreateTransaction({required List<int> tx}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_list_prim_u_8_loose(tx, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 28, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_String,
        decodeErrorData: sse_decode_AnyhowException,
      ),
      constMeta: kCrateApiApiCreateTransactionConstMeta,
      argValues: [tx],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiApiCreateTransactionConstMeta =>
      const TaskConstMeta(
        debugName: "api_create_transaction",
        argNames: ["tx"],
      );

  @override
  Future<WalletInstance> crateApiApiCreateWallet(
      {required BdkDescriptor descriptor,
      BdkDescriptor? changeDescriptor,
      required Network network,
      required DatabaseConfig databaseConfig}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_RustOpaque_BdkDescriptor(descriptor, serializer);
        sse_encode_opt_box_autoadd_RustOpaque_BdkDescriptor(
            changeDescriptor, serializer);
        sse_encode_network(network, serializer);
        sse_encode_box_autoadd_database_config(databaseConfig, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 29, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_RustOpaque_WalletInstance,
        decodeErrorData: sse_decode_AnyhowException,
      ),
      constMeta: kCrateApiApiCreateWalletConstMeta,
      argValues: [descriptor, changeDescriptor, network, databaseConfig],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiApiCreateWalletConstMeta => const TaskConstMeta(
        debugName: "api_create_wallet",
        argNames: [
          "descriptor",
          "changeDescriptor",
          "network",
          "databaseConfig"
        ],
      );

  @override
  Future<AddressInfo> crateApiApiDeriveAddressAt(
      {required BdkDescriptor descriptor,
      required int index,
      required Network network}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_RustOpaque_BdkDescriptor(descriptor, serializer);
        sse_encode_u_32(index, serializer);
        sse_encode_network(network, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 30, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_address_info,
        decodeErrorData: sse_decode_AnyhowException,
      ),
      constMeta: kCrateApiApiDeriveAddressAtConstMeta,
      argValues: [descriptor, index, network],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiApiDeriveAddressAtConstMeta => const TaskConstMeta(
        debugName: "api_derive_address_at",
        argNames: ["descriptor", "index", "network"],
      );

  @override
  Future<String> crateApiApiDeriveDescriptorSecret(
      {required String secret, required String path}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_String(secret, serializer);
        sse_encode_String(path, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 31, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_String,
        decodeErrorData: null,
      ),
      constMeta: kCrateApiApiDeriveDescriptorSecretConstMeta,
      argValues: [secret, path],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiApiDeriveDescriptorSecretConstMeta =>
      const TaskConstMeta(
        debugName: "api_derive_descriptor_secret",
        argNames: ["secret", "path"],
      );

  @override
  Future<String> crateApiApiDescriptorPublicFromString(
      {required String publicKey}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_String(publicKey, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 32, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_String,
        decodeErrorData: sse_decode_AnyhowException,
      ),
      constMeta: kCrateApiApiDescriptorPublicFromStringConstMeta,
      argValues: [publicKey],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiApiDescriptorPublicFromStringConstMeta =>
      const TaskConstMeta(
        debugName: "api_descriptor_public_from_string",
        argNames: ["publicKey"],
      );

  @override
  Future<String> crateApiApiDescriptorSecretFromString(
      {required String secret}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_String(secret, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 33, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_String,
        decodeErrorData: sse_decode_AnyhowException,
      ),
      constMeta: kCrateApiApiDescriptorSecretFromStringConstMeta,
      argValues: [secret],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiApiDescriptorSecretFromStringConstMeta =>
      const TaskConstMeta(
        debugName: "api_descriptor_secret_from_string",
        argNames: ["secret"],
      );

  @override
  Future<double> crateApiApiEstimateFee(
      {required BigInt target, required BlockchainInstance blockchain}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_u_64(target, serializer);
        sse_encode_RustOpaque_BlockchainInstance(blockchain, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 34, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_f_32,
        decodeErrorData: sse_decode_AnyhowException,
      ),
      constMeta: kCrateApiApiEstimateFeeConstMeta,
      argValues: [target, blockchain],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiApiEstimateFeeConstMeta => const TaskConstMeta(
        debugName: "api_estimate_fee",
        argNames: ["target", "blockchain"],
      );

  @override
  Future<String> crateApiApiExtendDescriptorSecret(
      {required String secret, required String path}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_String(secret, serializer);
        sse_encode_String(path, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 35, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_String,
        decodeErrorData: null,
      ),
      constMeta: kCrateApiApiExtendDescriptorSecretConstMeta,
      argValues: [secret, path],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiApiExtendDescriptorSecretConstMeta =>
      const TaskConstMeta(
        debugName: "api_extend_descriptor_secret",
        argNames: ["secret", "path"],
      );

  @override
  Future<String> crateApiApiExtractTx({required String psbtStr}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_String(psbtStr, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 36, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_String,
        decodeErrorData: sse_decode_AnyhowException,
      ),
      constMeta: kCrateApiApiExtractTxConstMeta,
      argValues: [psbtStr],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiApiExtractTxConstMeta => const TaskConstMeta(
        debugName: "api_extract_tx",
        argNames: ["psbtStr"],
      );

  @override
  Future<String> crateApiApiGenerateSeedFromEntropy(
      {required List<int> entropy}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_list_prim_u_8_loose(entropy, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 37, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_String,
        decodeErrorData: sse_decode_AnyhowException,
      ),
      constMeta: kCrateApiApiGenerateSeedFromEntropyConstMeta,
      argValues: [entropy],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiApiGenerateSeedFromEntropyConstMeta =>
      const TaskConstMeta(
        debugName: "api_generate_seed_from_entropy",
        argNames: ["entropy"],
      );

  @override
  Future<String> crateApiApiGenerateSeedFromString({required String mnemonic}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_String(mnemonic, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 38, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_String,
        decodeErrorData: sse_decode_AnyhowException,
      ),
      constMeta: kCrateApiApiGenerateSeedFromStringConstMeta,
      argValues: [mnemonic],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiApiGenerateSeedFromStringConstMeta =>
      const TaskConstMeta(
        debugName: "api_generate_seed_from_string",
        argNames: ["mnemonic"],
      );

  @override
  Future<String> crateApiApiGenerateSeedFromWordCount(
      {required WordCount wordCount}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_word_count(wordCount, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 39, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_String,
        decodeErrorData: null,
      ),
      constMeta: kCrateApiApiGenerateSeedFromWordCountConstMeta,
      argValues: [wordCount],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiApiGenerateSeedFromWordCountConstMeta =>
      const TaskConstMeta(
        debugName: "api_generate_seed_from_word_count",
        argNames: ["wordCount"],
      );

  @override
  Future<AddressInfo> crateApiApiGetAddress(
      {required WalletInstance wallet, required AddressIndex addressIndex}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_RustOpaque_WalletInstance(wallet, serializer);
        sse_encode_box_autoadd_address_index(addressIndex, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 40, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_address_info,
        decodeErrorData: sse_decode_AnyhowException,
      ),
      constMeta: kCrateApiApiGetAddressConstMeta,
      argValues: [wallet, addressIndex],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiApiGetAddressConstMeta => const TaskConstMeta(
        debugName: "api_get_address",
        argNames: ["wallet", "addressIndex"],
      );

  @override
  Future<String> crateApiApiGetAddressType({required String address}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_String(address, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 41, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_String,
        decodeErrorData: sse_decode_AnyhowException,
      ),
      constMeta: kCrateApiApiGetAddressTypeConstMeta,
      argValues: [address],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiApiGetAddressTypeConstMeta => const TaskConstMeta(
        debugName: "api_get_address_type",
        argNames: ["address"],
      );

  @override
  Future<Balance> crateApiApiGetBalance({required WalletInstance wallet}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_RustOpaque_WalletInstance(wallet, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 42, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_balance,
        decodeErrorData: sse_decode_AnyhowException,
      ),
      constMeta: kCrateApiApiGetBalanceConstMeta,
      argValues: [wallet],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiApiGetBalanceConstMeta => const TaskConstMeta(
        debugName: "api_get_balance",
        argNames: ["wallet"],
      );

  @override
  Future<String> crateApiApiGetBlockchainHash(
      {required int blockchainHeight, required BlockchainInstance blockchain}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_u_32(blockchainHeight, serializer);
        sse_encode_RustOpaque_BlockchainInstance(blockchain, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 43, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_String,
        decodeErrorData: sse_decode_AnyhowException,
      ),
      constMeta: kCrateApiApiGetBlockchainHashConstMeta,
      argValues: [blockchainHeight, blockchain],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiApiGetBlockchainHashConstMeta =>
      const TaskConstMeta(
        debugName: "api_get_blockchain_hash",
        argNames: ["blockchainHeight", "blockchain"],
      );

  @override
  Future<int> crateApiApiGetHeight({required BlockchainInstance blockchain}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_RustOpaque_BlockchainInstance(blockchain, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 44, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_u_32,
        decodeErrorData: sse_decode_AnyhowException,
      ),
      constMeta: kCrateApiApiGetHeightConstMeta,
      argValues: [blockchain],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiApiGetHeightConstMeta => const TaskConstMeta(
        debugName: "api_get_height",
        argNames: ["blockchain"],
      );

  @override
  Future<List<TxOut>> crateApiApiGetInputs({required String psbtStr}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_String(psbtStr, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 45, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_list_tx_out,
        decodeErrorData: sse_decode_AnyhowException,
      ),
      constMeta: kCrateApiApiGetInputsConstMeta,
      argValues: [psbtStr],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiApiGetInputsConstMeta => const TaskConstMeta(
        debugName: "api_get_inputs",
        argNames: ["psbtStr"],
      );

  @override
  Future<AddressInfo> crateApiApiGetInternalAddress(
      {required WalletInstance wallet, required AddressIndex addressIndex}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_RustOpaque_WalletInstance(wallet, serializer);
        sse_encode_box_autoadd_address_index(addressIndex, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 46, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_address_info,
        decodeErrorData: sse_decode_AnyhowException,
      ),
      constMeta: kCrateApiApiGetInternalAddressConstMeta,
      argValues: [wallet, addressIndex],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiApiGetInternalAddressConstMeta =>
      const TaskConstMeta(
        debugName: "api_get_internal_address",
        argNames: ["wallet", "addressIndex"],
      );

  @override
  Future<String> crateApiApiGetPubFromSecretBytes({required List<int> bytes}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_list_prim_u_8_loose(bytes, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 47, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_String,
        decodeErrorData: null,
      ),
      constMeta: kCrateApiApiGetPubFromSecretBytesConstMeta,
      argValues: [bytes],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiApiGetPubFromSecretBytesConstMeta =>
      const TaskConstMeta(
        debugName: "api_get_pub_from_secret_bytes",
        argNames: ["bytes"],
      );

  @override
  Future<List<TransactionDetails>> crateApiApiGetTransactions(
      {required WalletInstance wallet, required bool includeRaw}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_RustOpaque_WalletInstance(wallet, serializer);
        sse_encode_bool(includeRaw, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 48, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_list_transaction_details,
        decodeErrorData: sse_decode_AnyhowException,
      ),
      constMeta: kCrateApiApiGetTransactionsConstMeta,
      argValues: [wallet, includeRaw],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiApiGetTransactionsConstMeta => const TaskConstMeta(
        debugName: "api_get_transactions",
        argNames: ["wallet", "includeRaw"],
      );

  @override
  Future<String> crateApiApiGetTx(
      {required String tx, required BlockchainInstance blockchain}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_String(tx, serializer);
        sse_encode_RustOpaque_BlockchainInstance(blockchain, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 49, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_String,
        decodeErrorData: sse_decode_AnyhowException,
      ),
      constMeta: kCrateApiApiGetTxConstMeta,
      argValues: [tx, blockchain],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiApiGetTxConstMeta => const TaskConstMeta(
        debugName: "api_get_tx",
        argNames: ["tx", "blockchain"],
      );

  @override
  Future<BdkDescriptor> crateApiApiImportSingleWif(
      {required String wif,
      required String addressType,
      required Network network}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_String(wif, serializer);
        sse_encode_String(addressType, serializer);
        sse_encode_network(network, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 50, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_RustOpaque_BdkDescriptor,
        decodeErrorData: null,
      ),
      constMeta: kCrateApiApiImportSingleWifConstMeta,
      argValues: [wif, addressType, network],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiApiImportSingleWifConstMeta => const TaskConstMeta(
        debugName: "api_import_single_wif",
        argNames: ["wif", "addressType", "network"],
      );

  @override
  Future<List<TxIn>> crateApiApiInput({required String tx}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_String(tx, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 51, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_list_tx_in,
        decodeErrorData: null,
      ),
      constMeta: kCrateApiApiInputConstMeta,
      argValues: [tx],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiApiInputConstMeta => const TaskConstMeta(
        debugName: "api_input",
        argNames: ["tx"],
      );

  @override
  Future<bool> crateApiApiIsCoinBase({required String tx}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_String(tx, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 52, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_bool,
        decodeErrorData: null,
      ),
      constMeta: kCrateApiApiIsCoinBaseConstMeta,
      argValues: [tx],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiApiIsCoinBaseConstMeta => const TaskConstMeta(
        debugName: "api_is_coin_base",
        argNames: ["tx"],
      );

  @override
  Future<bool> crateApiApiIsExplicitlyRbf({required String tx}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_String(tx, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 53, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_bool,
        decodeErrorData: null,
      ),
      constMeta: kCrateApiApiIsExplicitlyRbfConstMeta,
      argValues: [tx],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiApiIsExplicitlyRbfConstMeta => const TaskConstMeta(
        debugName: "api_is_explicitly_rbf",
        argNames: ["tx"],
      );

  @override
  Future<bool> crateApiApiIsLockTimeEnabled({required String tx}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_String(tx, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 54, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_bool,
        decodeErrorData: null,
      ),
      constMeta: kCrateApiApiIsLockTimeEnabledConstMeta,
      argValues: [tx],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiApiIsLockTimeEnabledConstMeta =>
      const TaskConstMeta(
        debugName: "api_is_lock_time_enabled",
        argNames: ["tx"],
      );

  @override
  Future<String> crateApiApiJsonSerialize({required String psbtStr}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_String(psbtStr, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 55, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_String,
        decodeErrorData: sse_decode_AnyhowException,
      ),
      constMeta: kCrateApiApiJsonSerializeConstMeta,
      argValues: [psbtStr],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiApiJsonSerializeConstMeta => const TaskConstMeta(
        debugName: "api_json_serialize",
        argNames: ["psbtStr"],
      );

  @override
  Future<List<LocalUtxo>> crateApiApiListUnspent(
      {required WalletInstance wallet}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_RustOpaque_WalletInstance(wallet, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 56, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_list_local_utxo,
        decodeErrorData: sse_decode_AnyhowException,
      ),
      constMeta: kCrateApiApiListUnspentConstMeta,
      argValues: [wallet],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiApiListUnspentConstMeta => const TaskConstMeta(
        debugName: "api_list_unspent",
        argNames: ["wallet"],
      );

  @override
  Future<List<LocalUtxo>> crateApiApiListUnspentOutputs(
      {required WalletInstance wallet}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_RustOpaque_WalletInstance(wallet, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 57, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_list_local_utxo,
        decodeErrorData: sse_decode_AnyhowException,
      ),
      constMeta: kCrateApiApiListUnspentOutputsConstMeta,
      argValues: [wallet],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiApiListUnspentOutputsConstMeta =>
      const TaskConstMeta(
        debugName: "api_list_unspent_outputs",
        argNames: ["wallet"],
      );

  @override
  Future<int> crateApiApiLockTime({required String tx}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_String(tx, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 58, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_u_32,
        decodeErrorData: null,
      ),
      constMeta: kCrateApiApiLockTimeConstMeta,
      argValues: [tx],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiApiLockTimeConstMeta => const TaskConstMeta(
        debugName: "api_lock_time",
        argNames: ["tx"],
      );

  @override
  Future<String> crateApiApiMasterFinterprint({required String xpub}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_String(xpub, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 59, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_String,
        decodeErrorData: sse_decode_AnyhowException,
      ),
      constMeta: kCrateApiApiMasterFinterprintConstMeta,
      argValues: [xpub],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiApiMasterFinterprintConstMeta =>
      const TaskConstMeta(
        debugName: "api_master_finterprint",
        argNames: ["xpub"],
      );

  @override
  Future<BdkDescriptor> crateApiApiNewBip44Descriptor(
      {required KeychainKind keyChainKind,
      required String secretKey,
      required Network network}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_keychain_kind(keyChainKind, serializer);
        sse_encode_String(secretKey, serializer);
        sse_encode_network(network, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 60, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_RustOpaque_BdkDescriptor,
        decodeErrorData: null,
      ),
      constMeta: kCrateApiApiNewBip44DescriptorConstMeta,
      argValues: [keyChainKind, secretKey, network],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiApiNewBip44DescriptorConstMeta =>
      const TaskConstMeta(
        debugName: "api_new_bip44_descriptor",
        argNames: ["keyChainKind", "secretKey", "network"],
      );

  @override
  Future<BdkDescriptor> crateApiApiNewBip44Public(
      {required KeychainKind keyChainKind,
      required String publicKey,
      required Network network,
      required String fingerprint}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_keychain_kind(keyChainKind, serializer);
        sse_encode_String(publicKey, serializer);
        sse_encode_network(network, serializer);
        sse_encode_String(fingerprint, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 61, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_RustOpaque_BdkDescriptor,
        decodeErrorData: null,
      ),
      constMeta: kCrateApiApiNewBip44PublicConstMeta,
      argValues: [keyChainKind, publicKey, network, fingerprint],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiApiNewBip44PublicConstMeta => const TaskConstMeta(
        debugName: "api_new_bip44_public",
        argNames: ["keyChainKind", "publicKey", "network", "fingerprint"],
      );

  @override
  Future<BdkDescriptor> crateApiApiNewBip44TrDescriptor(
      {required KeychainKind keyChainKind,
      required String secretKey,
      required Network network}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_keychain_kind(keyChainKind, serializer);
        sse_encode_String(secretKey, serializer);
        sse_encode_network(network, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 62, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_RustOpaque_BdkDescriptor,
        decodeErrorData: null,
      ),
      constMeta: kCrateApiApiNewBip44TrDescriptorConstMeta,
      argValues: [keyChainKind, secretKey, network],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiApiNewBip44TrDescriptorConstMeta =>
      const TaskConstMeta(
        debugName: "api_new_bip44_tr_descriptor",
        argNames: ["keyChainKind", "secretKey", "network"],
      );

  @override
  Future<BdkDescriptor> crateApiApiNewBip44TrPublic(
      {required KeychainKind keyChainKind,
      required String publicKey,
      required Network network,
      required String fingerprint}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_keychain_kind(keyChainKind, serializer);
        sse_encode_String(publicKey, serializer);
        sse_encode_network(network, serializer);
        sse_encode_String(fingerprint, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 63, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_RustOpaque_BdkDescriptor,
        decodeErrorData: null,
      ),
      constMeta: kCrateApiApiNewBip44TrPublicConstMeta,
      argValues: [keyChainKind, publicKey, network, fingerprint],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiApiNewBip44TrPublicConstMeta =>
      const TaskConstMeta(
        debugName: "api_new_bip44_tr_public",
        argNames: ["keyChainKind", "publicKey", "network", "fingerprint"],
      );

  @override
  Future<BdkDescriptor> crateApiApiNewBip49Descriptor(
      {required KeychainKind keyChainKind,
      required String secretKey,
      required Network network}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_keychain_kind(keyChainKind, serializer);
        sse_encode_String(secretKey, serializer);
        sse_encode_network(network, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 64, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_RustOpaque_BdkDescriptor,
        decodeErrorData: null,
      ),
      constMeta: kCrateApiApiNewBip49DescriptorConstMeta,
      argValues: [keyChainKind, secretKey, network],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiApiNewBip49DescriptorConstMeta =>
      const TaskConstMeta(
        debugName: "api_new_bip49_descriptor",
        argNames: ["keyChainKind", "secretKey", "network"],
      );

  @override
  Future<BdkDescriptor> crateApiApiNewBip49Public(
      {required KeychainKind keyChainKind,
      required String publicKey,
      required Network network,
      required String fingerprint}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_keychain_kind(keyChainKind, serializer);
        sse_encode_String(publicKey, serializer);
        sse_encode_network(network, serializer);
        sse_encode_String(fingerprint, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 65, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_RustOpaque_BdkDescriptor,
        decodeErrorData: null,
      ),
      constMeta: kCrateApiApiNewBip49PublicConstMeta,
      argValues: [keyChainKind, publicKey, network, fingerprint],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiApiNewBip49PublicConstMeta => const TaskConstMeta(
        debugName: "api_new_bip49_public",
        argNames: ["keyChainKind", "publicKey", "network", "fingerprint"],
      );

  @override
  Future<BdkDescriptor> crateApiApiNewBip84Descriptor(
      {required KeychainKind keyChainKind,
      required String secretKey,
      required Network network}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_keychain_kind(keyChainKind, serializer);
        sse_encode_String(secretKey, serializer);
        sse_encode_network(network, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 66, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_RustOpaque_BdkDescriptor,
        decodeErrorData: null,
      ),
      constMeta: kCrateApiApiNewBip84DescriptorConstMeta,
      argValues: [keyChainKind, secretKey, network],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiApiNewBip84DescriptorConstMeta =>
      const TaskConstMeta(
        debugName: "api_new_bip84_descriptor",
        argNames: ["keyChainKind", "secretKey", "network"],
      );

  @override
  Future<BdkDescriptor> crateApiApiNewBip84Public(
      {required KeychainKind keyChainKind,
      required String publicKey,
      required Network network,
      required String fingerprint}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_keychain_kind(keyChainKind, serializer);
        sse_encode_String(publicKey, serializer);
        sse_encode_network(network, serializer);
        sse_encode_String(fingerprint, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 67, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_RustOpaque_BdkDescriptor,
        decodeErrorData: null,
      ),
      constMeta: kCrateApiApiNewBip84PublicConstMeta,
      argValues: [keyChainKind, publicKey, network, fingerprint],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiApiNewBip84PublicConstMeta => const TaskConstMeta(
        debugName: "api_new_bip84_public",
        argNames: ["keyChainKind", "publicKey", "network", "fingerprint"],
      );

  @override
  Future<BdkDescriptor> crateApiApiNewBip86Descriptor(
      {required KeychainKind keyChainKind,
      required String secretKey,
      required Network network}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_keychain_kind(keyChainKind, serializer);
        sse_encode_String(secretKey, serializer);
        sse_encode_network(network, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 68, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_RustOpaque_BdkDescriptor,
        decodeErrorData: null,
      ),
      constMeta: kCrateApiApiNewBip86DescriptorConstMeta,
      argValues: [keyChainKind, secretKey, network],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiApiNewBip86DescriptorConstMeta =>
      const TaskConstMeta(
        debugName: "api_new_bip86_descriptor",
        argNames: ["keyChainKind", "secretKey", "network"],
      );

  @override
  Future<BdkDescriptor> crateApiApiNewBip86Public(
      {required KeychainKind keyChainKind,
      required String publicKey,
      required Network network,
      required String fingerprint}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_keychain_kind(keyChainKind, serializer);
        sse_encode_String(publicKey, serializer);
        sse_encode_network(network, serializer);
        sse_encode_String(fingerprint, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 69, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_RustOpaque_BdkDescriptor,
        decodeErrorData: null,
      ),
      constMeta: kCrateApiApiNewBip86PublicConstMeta,
      argValues: [keyChainKind, publicKey, network, fingerprint],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiApiNewBip86PublicConstMeta => const TaskConstMeta(
        debugName: "api_new_bip86_public",
        argNames: ["keyChainKind", "publicKey", "network", "fingerprint"],
      );

  @override
  Future<List<TxOut>> crateApiApiOutput({required String tx}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_String(tx, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 70, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_list_tx_out,
        decodeErrorData: null,
      ),
      constMeta: kCrateApiApiOutputConstMeta,
      argValues: [tx],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiApiOutputConstMeta => const TaskConstMeta(
        debugName: "api_output",
        argNames: ["tx"],
      );

  @override
  Future<Payload> crateApiApiPayload({required String address}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_String(address, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 71, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_payload,
        decodeErrorData: sse_decode_AnyhowException,
      ),
      constMeta: kCrateApiApiPayloadConstMeta,
      argValues: [address],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiApiPayloadConstMeta => const TaskConstMeta(
        debugName: "api_payload",
        argNames: ["address"],
      );

  @override
  Future<BigInt?> crateApiApiPsbtFeeAmount({required String psbtStr}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_String(psbtStr, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 72, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_opt_box_autoadd_u_64,
        decodeErrorData: null,
      ),
      constMeta: kCrateApiApiPsbtFeeAmountConstMeta,
      argValues: [psbtStr],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiApiPsbtFeeAmountConstMeta => const TaskConstMeta(
        debugName: "api_psbt_fee_amount",
        argNames: ["psbtStr"],
      );

  @override
  Future<double?> crateApiApiPsbtFeeRate({required String psbtStr}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_String(psbtStr, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 73, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_opt_box_autoadd_f_32,
        decodeErrorData: null,
      ),
      constMeta: kCrateApiApiPsbtFeeRateConstMeta,
      argValues: [psbtStr],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiApiPsbtFeeRateConstMeta => const TaskConstMeta(
        debugName: "api_psbt_fee_rate",
        argNames: ["psbtStr"],
      );

  @override
  Future<String> crateApiApiPsbtTxid({required String psbtStr}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_String(psbtStr, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 74, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_String,
        decodeErrorData: sse_decode_AnyhowException,
      ),
      constMeta: kCrateApiApiPsbtTxidConstMeta,
      argValues: [psbtStr],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiApiPsbtTxidConstMeta => const TaskConstMeta(
        debugName: "api_psbt_txid",
        argNames: ["psbtStr"],
      );

  @override
  Future<String> crateApiApiSerializePsbt({required String psbtStr}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_String(psbtStr, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 75, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_String,
        decodeErrorData: sse_decode_AnyhowException,
      ),
      constMeta: kCrateApiApiSerializePsbtConstMeta,
      argValues: [psbtStr],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiApiSerializePsbtConstMeta => const TaskConstMeta(
        debugName: "api_serialize_psbt",
        argNames: ["psbtStr"],
      );

  @override
  Future<Uint8List> crateApiApiSerializeTx({required String tx}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_String(tx, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 76, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_list_prim_u_8_strict,
        decodeErrorData: null,
      ),
      constMeta: kCrateApiApiSerializeTxConstMeta,
      argValues: [tx],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiApiSerializeTxConstMeta => const TaskConstMeta(
        debugName: "api_serialize_tx",
        argNames: ["tx"],
      );

  @override
  Future<String?> crateApiApiSign(
      {required WalletInstance wallet,
      required String psbtStr,
      SignOptions? signOptions}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_RustOpaque_WalletInstance(wallet, serializer);
        sse_encode_String(psbtStr, serializer);
        sse_encode_opt_box_autoadd_sign_options(signOptions, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 77, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_opt_String,
        decodeErrorData: null,
      ),
      constMeta: kCrateApiApiSignConstMeta,
      argValues: [wallet, psbtStr, signOptions],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiApiSignConstMeta => const TaskConstMeta(
        debugName: "api_sign",
        argNames: ["wallet", "psbtStr", "signOptions"],
      );

  @override
  Future<BigInt> crateApiApiSize({required String tx}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_String(tx, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 78, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_u_64,
        decodeErrorData: null,
      ),
      constMeta: kCrateApiApiSizeConstMeta,
      argValues: [tx],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiApiSizeConstMeta => const TaskConstMeta(
        debugName: "api_size",
        argNames: ["tx"],
      );

  @override
  Future<String> crateApiApiToPublicString({required String xpub}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_String(xpub, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 79, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_String,
        decodeErrorData: sse_decode_AnyhowException,
      ),
      constMeta: kCrateApiApiToPublicStringConstMeta,
      argValues: [xpub],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiApiToPublicStringConstMeta => const TaskConstMeta(
        debugName: "api_to_public_string",
        argNames: ["xpub"],
      );

  @override
  Future<BdkTxBuilderResult> crateApiApiTxBuilderFinish(
      {required WalletInstance wallet,
      required List<ScriptAmount> recipients,
      required List<TxBytes> txs,
      required List<OutPoint> unspendable,
      required List<ForeignUtxo> foreignUtxos,
      required ChangeSpendPolicy changePolicy,
      required bool manuallySelectedOnly,
      double? feeRate,
      BigInt? feeAbsolute,
      required bool drainWallet,
      Script? drainTo,
      RbfValue? rbf,
      required List<int> data,
      bool? shuffleUtxo}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_RustOpaque_WalletInstance(wallet, serializer);
        sse_encode_list_script_amount(recipients, serializer);
        sse_encode_list_tx_bytes(txs, serializer);
        sse_encode_list_out_point(unspendable, serializer);
        sse_encode_list_foreign_utxo(foreignUtxos, serializer);
        sse_encode_change_spend_policy(changePolicy, serializer);
        sse_encode_bool(manuallySelectedOnly, serializer);
        sse_encode_opt_box_autoadd_f_32(feeRate, serializer);
        sse_encode_opt_box_autoadd_u_64(feeAbsolute, serializer);
        sse_encode_bool(drainWallet, serializer);
        sse_encode_opt_box_autoadd_script(drainTo, serializer);
        sse_encode_opt_box_autoadd_rbf_value(rbf, serializer);
        sse_encode_list_prim_u_8_loose(data, serializer);
        sse_encode_opt_box_autoadd_bool(shuffleUtxo, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 80, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_bdk_tx_builder_result,
        decodeErrorData: sse_decode_AnyhowException,
      ),
      constMeta: kCrateApiApiTxBuilderFinishConstMeta,
      argValues: [
        wallet,
        recipients,
        txs,
        unspendable,
        foreignUtxos,
        changePolicy,
        manuallySelectedOnly,
        feeRate,
        feeAbsolute,
        drainWallet,
        drainTo,
        rbf,
        data,
        shuffleUtxo
      ],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiApiTxBuilderFinishConstMeta => const TaskConstMeta(
        debugName: "api_tx_builder_finish",
        argNames: [
          "wallet",
          "recipients",
          "txs",
          "unspendable",
          "foreignUtxos",
          "changePolicy",
          "manuallySelectedOnly",
          "feeRate",
          "feeAbsolute",
          "drainWallet",
          "drainTo",
          "rbf",
          "data",
          "shuffleUtxo"
        ],
      );

  @override
  Future<BigInt> crateApiApiTxCalFeeFinish(
      {required WalletInstance wallet,
      required List<ScriptAmount> recipients,
      required List<TxBytes> txs,
      required List<OutPoint> unspendable,
      required List<ForeignUtxo> foreignUtxos,
      required ChangeSpendPolicy changePolicy,
      required bool manuallySelectedOnly,
      double? feeRate,
      BigInt? feeAbsolute,
      required bool drainWallet,
      Script? drainTo,
      RbfValue? rbf,
      required List<int> data,
      bool? shuffleUtxo}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_RustOpaque_WalletInstance(wallet, serializer);
        sse_encode_list_script_amount(recipients, serializer);
        sse_encode_list_tx_bytes(txs, serializer);
        sse_encode_list_out_point(unspendable, serializer);
        sse_encode_list_foreign_utxo(foreignUtxos, serializer);
        sse_encode_change_spend_policy(changePolicy, serializer);
        sse_encode_bool(manuallySelectedOnly, serializer);
        sse_encode_opt_box_autoadd_f_32(feeRate, serializer);
        sse_encode_opt_box_autoadd_u_64(feeAbsolute, serializer);
        sse_encode_bool(drainWallet, serializer);
        sse_encode_opt_box_autoadd_script(drainTo, serializer);
        sse_encode_opt_box_autoadd_rbf_value(rbf, serializer);
        sse_encode_list_prim_u_8_loose(data, serializer);
        sse_encode_opt_box_autoadd_bool(shuffleUtxo, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 81, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_u_64,
        decodeErrorData: sse_decode_AnyhowException,
      ),
      constMeta: kCrateApiApiTxCalFeeFinishConstMeta,
      argValues: [
        wallet,
        recipients,
        txs,
        unspendable,
        foreignUtxos,
        changePolicy,
        manuallySelectedOnly,
        feeRate,
        feeAbsolute,
        drainWallet,
        drainTo,
        rbf,
        data,
        shuffleUtxo
      ],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiApiTxCalFeeFinishConstMeta => const TaskConstMeta(
        debugName: "api_tx_cal_fee_finish",
        argNames: [
          "wallet",
          "recipients",
          "txs",
          "unspendable",
          "foreignUtxos",
          "changePolicy",
          "manuallySelectedOnly",
          "feeRate",
          "feeAbsolute",
          "drainWallet",
          "drainTo",
          "rbf",
          "data",
          "shuffleUtxo"
        ],
      );

  @override
  Future<String> crateApiApiTxTxid({required String tx}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_String(tx, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 82, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_String,
        decodeErrorData: sse_decode_AnyhowException,
      ),
      constMeta: kCrateApiApiTxTxidConstMeta,
      argValues: [tx],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiApiTxTxidConstMeta => const TaskConstMeta(
        debugName: "api_tx_txid",
        argNames: ["tx"],
      );

  @override
  Future<int> crateApiApiVersion({required String tx}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_String(tx, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 83, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_i_32,
        decodeErrorData: null,
      ),
      constMeta: kCrateApiApiVersionConstMeta,
      argValues: [tx],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiApiVersionConstMeta => const TaskConstMeta(
        debugName: "api_version",
        argNames: ["tx"],
      );

  @override
  Future<BigInt> crateApiApiVsize({required String tx}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_String(tx, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 84, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_u_64,
        decodeErrorData: null,
      ),
      constMeta: kCrateApiApiVsizeConstMeta,
      argValues: [tx],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiApiVsizeConstMeta => const TaskConstMeta(
        debugName: "api_vsize",
        argNames: ["tx"],
      );

  @override
  Future<Network> crateApiApiWalletNetwork({required WalletInstance wallet}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_RustOpaque_WalletInstance(wallet, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 85, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_network,
        decodeErrorData: null,
      ),
      constMeta: kCrateApiApiWalletNetworkConstMeta,
      argValues: [wallet],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiApiWalletNetworkConstMeta => const TaskConstMeta(
        debugName: "api_wallet_network",
        argNames: ["wallet"],
      );

  @override
  Future<BigInt> crateApiApiWeight({required String tx}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_String(tx, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 86, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_u_64,
        decodeErrorData: null,
      ),
      constMeta: kCrateApiApiWeightConstMeta,
      argValues: [tx],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiApiWeightConstMeta => const TaskConstMeta(
        debugName: "api_weight",
        argNames: ["tx"],
      );

  @override
  Future<bool> crateApiBlsInit() {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 87, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_bool,
        decodeErrorData: null,
      ),
      constMeta: kCrateApiBlsInitConstMeta,
      argValues: [],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiBlsInitConstMeta => const TaskConstMeta(
        debugName: "bls_init",
        argNames: [],
      );

  @override
  Future<bool> crateApiBlsVerify({required BLSVerifyReq req}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_box_autoadd_bls_verify_req(req, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 88, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_bool,
        decodeErrorData: null,
      ),
      constMeta: kCrateApiBlsVerifyConstMeta,
      argValues: [req],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiBlsVerifyConstMeta => const TaskConstMeta(
        debugName: "bls_verify",
        argNames: ["req"],
      );

  @override
  Future<ED25519Res> crateApiEd25519FromSeed(
      {required ED25519FromSeedReq req}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_box_autoadd_ed_25519_from_seed_req(req, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 89, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_ed_25519_res,
        decodeErrorData: null,
      ),
      constMeta: kCrateApiEd25519FromSeedConstMeta,
      argValues: [req],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiEd25519FromSeedConstMeta => const TaskConstMeta(
        debugName: "ed25519_from_seed",
        argNames: ["req"],
      );

  @override
  Future<Uint8List> crateApiEd25519Sign({required ED25519SignReq req}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_box_autoadd_ed_25519_sign_req(req, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 90, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_list_prim_u_8_strict,
        decodeErrorData: null,
      ),
      constMeta: kCrateApiEd25519SignConstMeta,
      argValues: [req],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiEd25519SignConstMeta => const TaskConstMeta(
        debugName: "ed25519_sign",
        argNames: ["req"],
      );

  @override
  Future<bool> crateApiEd25519Verify({required ED25519VerifyReq req}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_box_autoadd_ed_25519_verify_req(req, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 91, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_bool,
        decodeErrorData: null,
      ),
      constMeta: kCrateApiEd25519VerifyConstMeta,
      argValues: [req],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiEd25519VerifyConstMeta => const TaskConstMeta(
        debugName: "ed25519_verify",
        argNames: ["req"],
      );

  @override
  Future<String> crateApiHexBytesToWif(
      {required String hex, required Network network}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_String(hex, serializer);
        sse_encode_network(network, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 92, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_String,
        decodeErrorData: sse_decode_AnyhowException,
      ),
      constMeta: kCrateApiHexBytesToWifConstMeta,
      argValues: [hex, network],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiHexBytesToWifConstMeta => const TaskConstMeta(
        debugName: "hex_bytes_to_wif",
        argNames: ["hex", "network"],
      );

  @override
  Future<Uint8List> crateApiMnemonicPhraseToSeed(
      {required PhraseToSeedReq req}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_box_autoadd_phrase_to_seed_req(req, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 93, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_list_prim_u_8_strict,
        decodeErrorData: null,
      ),
      constMeta: kCrateApiMnemonicPhraseToSeedConstMeta,
      argValues: [req],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiMnemonicPhraseToSeedConstMeta =>
      const TaskConstMeta(
        debugName: "mnemonic_phrase_to_seed",
        argNames: ["req"],
      );

  @override
  Future<Uint8List> crateApiMnemonicSeedToKey({required SeedToKeyReq req}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_box_autoadd_seed_to_key_req(req, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 94, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_list_prim_u_8_strict,
        decodeErrorData: null,
      ),
      constMeta: kCrateApiMnemonicSeedToKeyConstMeta,
      argValues: [req],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiMnemonicSeedToKeyConstMeta => const TaskConstMeta(
        debugName: "mnemonic_seed_to_key",
        argNames: ["req"],
      );

  @override
  Future<P256IdentityExport> crateApiP256FromSeed(
      {required P256FromSeedReq req}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_box_autoadd_p_256_from_seed_req(req, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 95, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_p_256_identity_export,
        decodeErrorData: null,
      ),
      constMeta: kCrateApiP256FromSeedConstMeta,
      argValues: [req],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiP256FromSeedConstMeta => const TaskConstMeta(
        debugName: "p256_from_seed",
        argNames: ["req"],
      );

  @override
  Future<Uint8List> crateApiP256GetSharedSecret(
      {required P256ShareSecretReq req}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_box_autoadd_p_256_share_secret_req(req, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 96, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_list_prim_u_8_strict,
        decodeErrorData: null,
      ),
      constMeta: kCrateApiP256GetSharedSecretConstMeta,
      argValues: [req],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiP256GetSharedSecretConstMeta =>
      const TaskConstMeta(
        debugName: "p256_get_shared_secret",
        argNames: ["req"],
      );

  @override
  Future<SignatureFFI> crateApiP256Sign({required P256SignWithSeedReq req}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_box_autoadd_p_256_sign_with_seed_req(req, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 97, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_signature_ffi,
        decodeErrorData: null,
      ),
      constMeta: kCrateApiP256SignConstMeta,
      argValues: [req],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiP256SignConstMeta => const TaskConstMeta(
        debugName: "p256_sign",
        argNames: ["req"],
      );

  @override
  Future<bool> crateApiP256Verify({required P256VerifyReq req}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_box_autoadd_p_256_verify_req(req, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 98, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_bool,
        decodeErrorData: null,
      ),
      constMeta: kCrateApiP256VerifyConstMeta,
      argValues: [req],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiP256VerifyConstMeta => const TaskConstMeta(
        debugName: "p256_verify",
        argNames: ["req"],
      );

  @override
  Future<KeyDerivedRes> crateApiPbkdf2DeriveKey({required PBKDFDeriveReq req}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_box_autoadd_pbkdf_derive_req(req, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 99, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_key_derived_res,
        decodeErrorData: null,
      ),
      constMeta: kCrateApiPbkdf2DeriveKeyConstMeta,
      argValues: [req],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiPbkdf2DeriveKeyConstMeta => const TaskConstMeta(
        debugName: "pbkdf2_derive_key",
        argNames: ["req"],
      );

  @override
  Future<SchnorrIdentityExport> crateApiSchnorrFromSeed(
      {required SchnorrFromSeedReq req}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_box_autoadd_schnorr_from_seed_req(req, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 100, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_schnorr_identity_export,
        decodeErrorData: null,
      ),
      constMeta: kCrateApiSchnorrFromSeedConstMeta,
      argValues: [req],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiSchnorrFromSeedConstMeta => const TaskConstMeta(
        debugName: "schnorr_from_seed",
        argNames: ["req"],
      );

  @override
  Future<SignatureFFI> crateApiSchnorrSign(
      {required SchnorrSignWithSeedReq req}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_box_autoadd_schnorr_sign_with_seed_req(req, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 101, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_signature_ffi,
        decodeErrorData: null,
      ),
      constMeta: kCrateApiSchnorrSignConstMeta,
      argValues: [req],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiSchnorrSignConstMeta => const TaskConstMeta(
        debugName: "schnorr_sign",
        argNames: ["req"],
      );

  @override
  Future<bool> crateApiSchnorrVerify({required SchnorrVerifyReq req}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_box_autoadd_schnorr_verify_req(req, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 102, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_bool,
        decodeErrorData: null,
      ),
      constMeta: kCrateApiSchnorrVerifyConstMeta,
      argValues: [req],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiSchnorrVerifyConstMeta => const TaskConstMeta(
        debugName: "schnorr_verify",
        argNames: ["req"],
      );

  @override
  Future<KeyDerivedRes> crateApiScryptDeriveKey(
      {required ScriptDeriveReq req}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_box_autoadd_script_derive_req(req, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 103, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_key_derived_res,
        decodeErrorData: null,
      ),
      constMeta: kCrateApiScryptDeriveKeyConstMeta,
      argValues: [req],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiScryptDeriveKeyConstMeta => const TaskConstMeta(
        debugName: "scrypt_derive_key",
        argNames: ["req"],
      );

  @override
  Future<Secp256k1IdentityExport> crateApiSecp256K1FromSeed(
      {required Secp256k1FromSeedReq req}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_box_autoadd_secp_256_k_1_from_seed_req(req, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 104, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_secp_256_k_1_identity_export,
        decodeErrorData: null,
      ),
      constMeta: kCrateApiSecp256K1FromSeedConstMeta,
      argValues: [req],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiSecp256K1FromSeedConstMeta => const TaskConstMeta(
        debugName: "secp256k1_from_seed",
        argNames: ["req"],
      );

  @override
  Future<Uint8List> crateApiSecp256K1GetSharedSecret(
      {required Secp256k1ShareSecretReq req}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_box_autoadd_secp_256_k_1_share_secret_req(req, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 105, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_list_prim_u_8_strict,
        decodeErrorData: null,
      ),
      constMeta: kCrateApiSecp256K1GetSharedSecretConstMeta,
      argValues: [req],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiSecp256K1GetSharedSecretConstMeta =>
      const TaskConstMeta(
        debugName: "secp256k1_get_shared_secret",
        argNames: ["req"],
      );

  @override
  Future<Uint8List> crateApiSecp256K1Recover(
      {required Secp256k1RecoverReq req}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_box_autoadd_secp_256_k_1_recover_req(req, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 106, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_list_prim_u_8_strict,
        decodeErrorData: null,
      ),
      constMeta: kCrateApiSecp256K1RecoverConstMeta,
      argValues: [req],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiSecp256K1RecoverConstMeta => const TaskConstMeta(
        debugName: "secp256k1_recover",
        argNames: ["req"],
      );

  @override
  Future<SignatureFFI> crateApiSecp256K1Sign(
      {required Secp256k1SignWithSeedReq req}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_box_autoadd_secp_256_k_1_sign_with_seed_req(req, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 107, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_signature_ffi,
        decodeErrorData: null,
      ),
      constMeta: kCrateApiSecp256K1SignConstMeta,
      argValues: [req],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiSecp256K1SignConstMeta => const TaskConstMeta(
        debugName: "secp256k1_sign",
        argNames: ["req"],
      );

  @override
  Future<SignatureFFI> crateApiSecp256K1SignRecoverable(
      {required Secp256k1SignWithSeedReq req}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_box_autoadd_secp_256_k_1_sign_with_seed_req(req, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 108, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_signature_ffi,
        decodeErrorData: null,
      ),
      constMeta: kCrateApiSecp256K1SignRecoverableConstMeta,
      argValues: [req],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiSecp256K1SignRecoverableConstMeta =>
      const TaskConstMeta(
        debugName: "secp256k1_sign_recoverable",
        argNames: ["req"],
      );

  @override
  Future<SignatureFFI> crateApiSecp256K1SignWithRng(
      {required Secp256k1SignWithRngReq req}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_box_autoadd_secp_256_k_1_sign_with_rng_req(req, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 109, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_signature_ffi,
        decodeErrorData: null,
      ),
      constMeta: kCrateApiSecp256K1SignWithRngConstMeta,
      argValues: [req],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiSecp256K1SignWithRngConstMeta =>
      const TaskConstMeta(
        debugName: "secp256k1_sign_with_rng",
        argNames: ["req"],
      );

  @override
  Future<bool> crateApiSecp256K1Verify({required Secp256k1VerifyReq req}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_box_autoadd_secp_256_k_1_verify_req(req, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 110, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_bool,
        decodeErrorData: null,
      ),
      constMeta: kCrateApiSecp256K1VerifyConstMeta,
      argValues: [req],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiSecp256K1VerifyConstMeta => const TaskConstMeta(
        debugName: "secp256k1_verify",
        argNames: ["req"],
      );

  RustArcIncrementStrongCountFnType
      get rust_arc_increment_strong_count_BdkDescriptor =>
          wire.rust_arc_increment_strong_count_RustOpaque_BdkDescriptor;

  RustArcDecrementStrongCountFnType
      get rust_arc_decrement_strong_count_BdkDescriptor =>
          wire.rust_arc_decrement_strong_count_RustOpaque_BdkDescriptor;

  RustArcIncrementStrongCountFnType
      get rust_arc_increment_strong_count_BlockchainInstance =>
          wire.rust_arc_increment_strong_count_RustOpaque_BlockchainInstance;

  RustArcDecrementStrongCountFnType
      get rust_arc_decrement_strong_count_BlockchainInstance =>
          wire.rust_arc_decrement_strong_count_RustOpaque_BlockchainInstance;

  RustArcIncrementStrongCountFnType
      get rust_arc_increment_strong_count_WalletInstance =>
          wire.rust_arc_increment_strong_count_RustOpaque_WalletInstance;

  RustArcDecrementStrongCountFnType
      get rust_arc_decrement_strong_count_WalletInstance =>
          wire.rust_arc_decrement_strong_count_RustOpaque_WalletInstance;

  @protected
  AnyhowException dco_decode_AnyhowException(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return AnyhowException(raw as String);
  }

  @protected
  BdkDescriptor dco_decode_RustOpaque_BdkDescriptor(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return BdkDescriptorImpl.frbInternalDcoDecode(raw as List<dynamic>);
  }

  @protected
  BlockchainInstance dco_decode_RustOpaque_BlockchainInstance(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return BlockchainInstanceImpl.frbInternalDcoDecode(raw as List<dynamic>);
  }

  @protected
  WalletInstance dco_decode_RustOpaque_WalletInstance(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return WalletInstanceImpl.frbInternalDcoDecode(raw as List<dynamic>);
  }

  @protected
  String dco_decode_String(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw as String;
  }

  @protected
  AddressIndex dco_decode_address_index(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    switch (raw[0]) {
      case 0:
        return AddressIndex_NewIndex();
      case 1:
        return AddressIndex_LastUnused();
      case 2:
        return AddressIndex_Peek(
          index: dco_decode_u_32(raw[1]),
        );
      case 3:
        return AddressIndex_Reset(
          index: dco_decode_u_32(raw[1]),
        );
      default:
        throw Exception("unreachable");
    }
  }

  @protected
  AddressInfo dco_decode_address_info(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 2)
      throw Exception('unexpected arr length: expect 2 but see ${arr.length}');
    return AddressInfo(
      index: dco_decode_u_32(arr[0]),
      address: dco_decode_String(arr[1]),
    );
  }

  @protected
  AesDecryptReq dco_decode_aes_decrypt_req(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 3)
      throw Exception('unexpected arr length: expect 3 but see ${arr.length}');
    return AesDecryptReq(
      key: dco_decode_list_prim_u_8_strict(arr[0]),
      iv: dco_decode_list_prim_u_8_strict(arr[1]),
      cipherText: dco_decode_list_prim_u_8_strict(arr[2]),
    );
  }

  @protected
  AesEncryptReq dco_decode_aes_encrypt_req(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 3)
      throw Exception('unexpected arr length: expect 3 but see ${arr.length}');
    return AesEncryptReq(
      key: dco_decode_list_prim_u_8_strict(arr[0]),
      iv: dco_decode_list_prim_u_8_strict(arr[1]),
      message: dco_decode_list_prim_u_8_strict(arr[2]),
    );
  }

  @protected
  Api dco_decode_api(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 0)
      throw Exception('unexpected arr length: expect 0 but see ${arr.length}');
    return Api();
  }

  @protected
  Balance dco_decode_balance(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 6)
      throw Exception('unexpected arr length: expect 6 but see ${arr.length}');
    return Balance(
      immature: dco_decode_u_64(arr[0]),
      trustedPending: dco_decode_u_64(arr[1]),
      untrustedPending: dco_decode_u_64(arr[2]),
      confirmed: dco_decode_u_64(arr[3]),
      spendable: dco_decode_u_64(arr[4]),
      total: dco_decode_u_64(arr[5]),
    );
  }

  @protected
  BdkTxBuilderResult dco_decode_bdk_tx_builder_result(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 2)
      throw Exception('unexpected arr length: expect 2 but see ${arr.length}');
    return BdkTxBuilderResult(
      field0: dco_decode_String(arr[0]),
      field1: dco_decode_transaction_details(arr[1]),
    );
  }

  @protected
  BlockTime dco_decode_block_time(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 2)
      throw Exception('unexpected arr length: expect 2 but see ${arr.length}');
    return BlockTime(
      height: dco_decode_u_32(arr[0]),
      timestamp: dco_decode_u_64(arr[1]),
    );
  }

  @protected
  BlockchainConfig dco_decode_blockchain_config(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    switch (raw[0]) {
      case 0:
        return BlockchainConfig_Electrum(
          config: dco_decode_box_autoadd_electrum_config(raw[1]),
        );
      case 1:
        return BlockchainConfig_Esplora(
          config: dco_decode_box_autoadd_esplora_config(raw[1]),
        );
      case 2:
        return BlockchainConfig_Rpc(
          config: dco_decode_box_autoadd_rpc_config(raw[1]),
        );
      default:
        throw Exception("unreachable");
    }
  }

  @protected
  BLSVerifyReq dco_decode_bls_verify_req(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 3)
      throw Exception('unexpected arr length: expect 3 but see ${arr.length}');
    return BLSVerifyReq(
      signature: dco_decode_list_prim_u_8_strict(arr[0]),
      message: dco_decode_list_prim_u_8_strict(arr[1]),
      publicKey: dco_decode_list_prim_u_8_strict(arr[2]),
    );
  }

  @protected
  bool dco_decode_bool(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw as bool;
  }

  @protected
  BdkDescriptor dco_decode_box_autoadd_RustOpaque_BdkDescriptor(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_RustOpaque_BdkDescriptor(raw);
  }

  @protected
  AddressIndex dco_decode_box_autoadd_address_index(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_address_index(raw);
  }

  @protected
  AesDecryptReq dco_decode_box_autoadd_aes_decrypt_req(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_aes_decrypt_req(raw);
  }

  @protected
  AesEncryptReq dco_decode_box_autoadd_aes_encrypt_req(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_aes_encrypt_req(raw);
  }

  @protected
  BlockTime dco_decode_box_autoadd_block_time(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_block_time(raw);
  }

  @protected
  BlockchainConfig dco_decode_box_autoadd_blockchain_config(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_blockchain_config(raw);
  }

  @protected
  BLSVerifyReq dco_decode_box_autoadd_bls_verify_req(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_bls_verify_req(raw);
  }

  @protected
  bool dco_decode_box_autoadd_bool(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw as bool;
  }

  @protected
  DatabaseConfig dco_decode_box_autoadd_database_config(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_database_config(raw);
  }

  @protected
  ED25519FromSeedReq dco_decode_box_autoadd_ed_25519_from_seed_req(
      dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_ed_25519_from_seed_req(raw);
  }

  @protected
  ED25519SignReq dco_decode_box_autoadd_ed_25519_sign_req(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_ed_25519_sign_req(raw);
  }

  @protected
  ED25519VerifyReq dco_decode_box_autoadd_ed_25519_verify_req(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_ed_25519_verify_req(raw);
  }

  @protected
  ElectrumConfig dco_decode_box_autoadd_electrum_config(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_electrum_config(raw);
  }

  @protected
  EsploraConfig dco_decode_box_autoadd_esplora_config(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_esplora_config(raw);
  }

  @protected
  double dco_decode_box_autoadd_f_32(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw as double;
  }

  @protected
  P256FromSeedReq dco_decode_box_autoadd_p_256_from_seed_req(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_p_256_from_seed_req(raw);
  }

  @protected
  P256ShareSecretReq dco_decode_box_autoadd_p_256_share_secret_req(
      dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_p_256_share_secret_req(raw);
  }

  @protected
  P256SignWithSeedReq dco_decode_box_autoadd_p_256_sign_with_seed_req(
      dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_p_256_sign_with_seed_req(raw);
  }

  @protected
  P256VerifyReq dco_decode_box_autoadd_p_256_verify_req(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_p_256_verify_req(raw);
  }

  @protected
  PBKDFDeriveReq dco_decode_box_autoadd_pbkdf_derive_req(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_pbkdf_derive_req(raw);
  }

  @protected
  PhraseToSeedReq dco_decode_box_autoadd_phrase_to_seed_req(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_phrase_to_seed_req(raw);
  }

  @protected
  RbfValue dco_decode_box_autoadd_rbf_value(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_rbf_value(raw);
  }

  @protected
  RpcConfig dco_decode_box_autoadd_rpc_config(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_rpc_config(raw);
  }

  @protected
  RpcSyncParams dco_decode_box_autoadd_rpc_sync_params(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_rpc_sync_params(raw);
  }

  @protected
  SchnorrFromSeedReq dco_decode_box_autoadd_schnorr_from_seed_req(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_schnorr_from_seed_req(raw);
  }

  @protected
  SchnorrSignWithSeedReq dco_decode_box_autoadd_schnorr_sign_with_seed_req(
      dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_schnorr_sign_with_seed_req(raw);
  }

  @protected
  SchnorrVerifyReq dco_decode_box_autoadd_schnorr_verify_req(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_schnorr_verify_req(raw);
  }

  @protected
  Script dco_decode_box_autoadd_script(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_script(raw);
  }

  @protected
  ScriptDeriveReq dco_decode_box_autoadd_script_derive_req(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_script_derive_req(raw);
  }

  @protected
  Secp256k1FromSeedReq dco_decode_box_autoadd_secp_256_k_1_from_seed_req(
      dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_secp_256_k_1_from_seed_req(raw);
  }

  @protected
  Secp256k1RecoverReq dco_decode_box_autoadd_secp_256_k_1_recover_req(
      dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_secp_256_k_1_recover_req(raw);
  }

  @protected
  Secp256k1ShareSecretReq dco_decode_box_autoadd_secp_256_k_1_share_secret_req(
      dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_secp_256_k_1_share_secret_req(raw);
  }

  @protected
  Secp256k1SignWithRngReq dco_decode_box_autoadd_secp_256_k_1_sign_with_rng_req(
      dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_secp_256_k_1_sign_with_rng_req(raw);
  }

  @protected
  Secp256k1SignWithSeedReq
      dco_decode_box_autoadd_secp_256_k_1_sign_with_seed_req(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_secp_256_k_1_sign_with_seed_req(raw);
  }

  @protected
  Secp256k1VerifyReq dco_decode_box_autoadd_secp_256_k_1_verify_req(
      dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_secp_256_k_1_verify_req(raw);
  }

  @protected
  SeedToKeyReq dco_decode_box_autoadd_seed_to_key_req(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_seed_to_key_req(raw);
  }

  @protected
  SignOptions dco_decode_box_autoadd_sign_options(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_sign_options(raw);
  }

  @protected
  SledDbConfiguration dco_decode_box_autoadd_sled_db_configuration(
      dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_sled_db_configuration(raw);
  }

  @protected
  SqliteDbConfiguration dco_decode_box_autoadd_sqlite_db_configuration(
      dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_sqlite_db_configuration(raw);
  }

  @protected
  int dco_decode_box_autoadd_u_32(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw as int;
  }

  @protected
  BigInt dco_decode_box_autoadd_u_64(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_u_64(raw);
  }

  @protected
  int dco_decode_box_autoadd_u_8(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw as int;
  }

  @protected
  UserPass dco_decode_box_autoadd_user_pass(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_user_pass(raw);
  }

  @protected
  ChangeSpendPolicy dco_decode_change_spend_policy(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return ChangeSpendPolicy.values[raw as int];
  }

  @protected
  DatabaseConfig dco_decode_database_config(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    switch (raw[0]) {
      case 0:
        return DatabaseConfig_Memory();
      case 1:
        return DatabaseConfig_Sqlite(
          config: dco_decode_box_autoadd_sqlite_db_configuration(raw[1]),
        );
      case 2:
        return DatabaseConfig_Sled(
          config: dco_decode_box_autoadd_sled_db_configuration(raw[1]),
        );
      default:
        throw Exception("unreachable");
    }
  }

  @protected
  ED25519FromSeedReq dco_decode_ed_25519_from_seed_req(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 1)
      throw Exception('unexpected arr length: expect 1 but see ${arr.length}');
    return ED25519FromSeedReq(
      seed: dco_decode_list_prim_u_8_strict(arr[0]),
    );
  }

  @protected
  ED25519Res dco_decode_ed_25519_res(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 2)
      throw Exception('unexpected arr length: expect 2 but see ${arr.length}');
    return ED25519Res(
      seed: dco_decode_list_prim_u_8_strict(arr[0]),
      publicKey: dco_decode_list_prim_u_8_strict(arr[1]),
    );
  }

  @protected
  ED25519SignReq dco_decode_ed_25519_sign_req(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 2)
      throw Exception('unexpected arr length: expect 2 but see ${arr.length}');
    return ED25519SignReq(
      seed: dco_decode_list_prim_u_8_strict(arr[0]),
      message: dco_decode_list_prim_u_8_strict(arr[1]),
    );
  }

  @protected
  ED25519VerifyReq dco_decode_ed_25519_verify_req(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 3)
      throw Exception('unexpected arr length: expect 3 but see ${arr.length}');
    return ED25519VerifyReq(
      sig: dco_decode_list_prim_u_8_strict(arr[0]),
      message: dco_decode_list_prim_u_8_strict(arr[1]),
      pubKey: dco_decode_list_prim_u_8_strict(arr[2]),
    );
  }

  @protected
  ElectrumConfig dco_decode_electrum_config(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 6)
      throw Exception('unexpected arr length: expect 6 but see ${arr.length}');
    return ElectrumConfig(
      url: dco_decode_String(arr[0]),
      socks5: dco_decode_opt_String(arr[1]),
      retry: dco_decode_u_8(arr[2]),
      timeout: dco_decode_opt_box_autoadd_u_8(arr[3]),
      stopGap: dco_decode_u_64(arr[4]),
      validateDomain: dco_decode_bool(arr[5]),
    );
  }

  @protected
  EsploraConfig dco_decode_esplora_config(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 5)
      throw Exception('unexpected arr length: expect 5 but see ${arr.length}');
    return EsploraConfig(
      baseUrl: dco_decode_String(arr[0]),
      proxy: dco_decode_opt_String(arr[1]),
      concurrency: dco_decode_opt_box_autoadd_u_8(arr[2]),
      stopGap: dco_decode_u_64(arr[3]),
      timeout: dco_decode_opt_box_autoadd_u_64(arr[4]),
    );
  }

  @protected
  double dco_decode_f_32(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw as double;
  }

  @protected
  ForeignUtxo dco_decode_foreign_utxo(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 2)
      throw Exception('unexpected arr length: expect 2 but see ${arr.length}');
    return ForeignUtxo(
      outpoint: dco_decode_out_point(arr[0]),
      txout: dco_decode_tx_out_foreign(arr[1]),
    );
  }

  @protected
  int dco_decode_i_32(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw as int;
  }

  @protected
  KeyDerivedRes dco_decode_key_derived_res(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 2)
      throw Exception('unexpected arr length: expect 2 but see ${arr.length}');
    return KeyDerivedRes(
      leftBits: dco_decode_list_prim_u_8_strict(arr[0]),
      rightBits: dco_decode_list_prim_u_8_strict(arr[1]),
    );
  }

  @protected
  KeychainKind dco_decode_keychain_kind(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return KeychainKind.values[raw as int];
  }

  @protected
  List<String> dco_decode_list_String(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return (raw as List<dynamic>).map(dco_decode_String).toList();
  }

  @protected
  List<ForeignUtxo> dco_decode_list_foreign_utxo(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return (raw as List<dynamic>).map(dco_decode_foreign_utxo).toList();
  }

  @protected
  List<LocalUtxo> dco_decode_list_local_utxo(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return (raw as List<dynamic>).map(dco_decode_local_utxo).toList();
  }

  @protected
  List<OutPoint> dco_decode_list_out_point(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return (raw as List<dynamic>).map(dco_decode_out_point).toList();
  }

  @protected
  List<int> dco_decode_list_prim_u_8_loose(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw as List<int>;
  }

  @protected
  Uint8List dco_decode_list_prim_u_8_strict(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw as Uint8List;
  }

  @protected
  List<ScriptAmount> dco_decode_list_script_amount(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return (raw as List<dynamic>).map(dco_decode_script_amount).toList();
  }

  @protected
  List<TransactionDetails> dco_decode_list_transaction_details(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return (raw as List<dynamic>).map(dco_decode_transaction_details).toList();
  }

  @protected
  List<TxBytes> dco_decode_list_tx_bytes(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return (raw as List<dynamic>).map(dco_decode_tx_bytes).toList();
  }

  @protected
  List<TxIn> dco_decode_list_tx_in(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return (raw as List<dynamic>).map(dco_decode_tx_in).toList();
  }

  @protected
  List<TxOut> dco_decode_list_tx_out(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return (raw as List<dynamic>).map(dco_decode_tx_out).toList();
  }

  @protected
  LocalUtxo dco_decode_local_utxo(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 4)
      throw Exception('unexpected arr length: expect 4 but see ${arr.length}');
    return LocalUtxo(
      outpoint: dco_decode_out_point(arr[0]),
      txout: dco_decode_tx_out(arr[1]),
      isSpent: dco_decode_bool(arr[2]),
      keychain: dco_decode_keychain_kind(arr[3]),
    );
  }

  @protected
  Network dco_decode_network(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return Network.values[raw as int];
  }

  @protected
  String? dco_decode_opt_String(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw == null ? null : dco_decode_String(raw);
  }

  @protected
  BdkDescriptor? dco_decode_opt_box_autoadd_RustOpaque_BdkDescriptor(
      dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw == null
        ? null
        : dco_decode_box_autoadd_RustOpaque_BdkDescriptor(raw);
  }

  @protected
  BlockTime? dco_decode_opt_box_autoadd_block_time(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw == null ? null : dco_decode_box_autoadd_block_time(raw);
  }

  @protected
  bool? dco_decode_opt_box_autoadd_bool(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw == null ? null : dco_decode_box_autoadd_bool(raw);
  }

  @protected
  double? dco_decode_opt_box_autoadd_f_32(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw == null ? null : dco_decode_box_autoadd_f_32(raw);
  }

  @protected
  RbfValue? dco_decode_opt_box_autoadd_rbf_value(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw == null ? null : dco_decode_box_autoadd_rbf_value(raw);
  }

  @protected
  RpcSyncParams? dco_decode_opt_box_autoadd_rpc_sync_params(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw == null ? null : dco_decode_box_autoadd_rpc_sync_params(raw);
  }

  @protected
  Script? dco_decode_opt_box_autoadd_script(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw == null ? null : dco_decode_box_autoadd_script(raw);
  }

  @protected
  SignOptions? dco_decode_opt_box_autoadd_sign_options(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw == null ? null : dco_decode_box_autoadd_sign_options(raw);
  }

  @protected
  int? dco_decode_opt_box_autoadd_u_32(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw == null ? null : dco_decode_box_autoadd_u_32(raw);
  }

  @protected
  BigInt? dco_decode_opt_box_autoadd_u_64(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw == null ? null : dco_decode_box_autoadd_u_64(raw);
  }

  @protected
  int? dco_decode_opt_box_autoadd_u_8(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw == null ? null : dco_decode_box_autoadd_u_8(raw);
  }

  @protected
  UserPass? dco_decode_opt_box_autoadd_user_pass(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw == null ? null : dco_decode_box_autoadd_user_pass(raw);
  }

  @protected
  Uint8List? dco_decode_opt_list_prim_u_8_strict(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw == null ? null : dco_decode_list_prim_u_8_strict(raw);
  }

  @protected
  OutPoint dco_decode_out_point(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 2)
      throw Exception('unexpected arr length: expect 2 but see ${arr.length}');
    return OutPoint(
      txid: dco_decode_String(arr[0]),
      vout: dco_decode_u_32(arr[1]),
    );
  }

  @protected
  P256FromSeedReq dco_decode_p_256_from_seed_req(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 1)
      throw Exception('unexpected arr length: expect 1 but see ${arr.length}');
    return P256FromSeedReq(
      seed: dco_decode_list_prim_u_8_strict(arr[0]),
    );
  }

  @protected
  P256IdentityExport dco_decode_p_256_identity_export(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 2)
      throw Exception('unexpected arr length: expect 2 but see ${arr.length}');
    return P256IdentityExport(
      privateKeyHash: dco_decode_list_prim_u_8_strict(arr[0]),
      derEncodedPublicKey: dco_decode_list_prim_u_8_strict(arr[1]),
    );
  }

  @protected
  P256ShareSecretReq dco_decode_p_256_share_secret_req(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 2)
      throw Exception('unexpected arr length: expect 2 but see ${arr.length}');
    return P256ShareSecretReq(
      seed: dco_decode_list_prim_u_8_strict(arr[0]),
      publicKeyRawBytes: dco_decode_list_prim_u_8_strict(arr[1]),
    );
  }

  @protected
  P256SignWithSeedReq dco_decode_p_256_sign_with_seed_req(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 2)
      throw Exception('unexpected arr length: expect 2 but see ${arr.length}');
    return P256SignWithSeedReq(
      msg: dco_decode_list_prim_u_8_strict(arr[0]),
      seed: dco_decode_list_prim_u_8_strict(arr[1]),
    );
  }

  @protected
  P256VerifyReq dco_decode_p_256_verify_req(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 3)
      throw Exception('unexpected arr length: expect 3 but see ${arr.length}');
    return P256VerifyReq(
      messageHash: dco_decode_list_prim_u_8_strict(arr[0]),
      signatureBytes: dco_decode_list_prim_u_8_strict(arr[1]),
      publicKeyBytes: dco_decode_list_prim_u_8_strict(arr[2]),
    );
  }

  @protected
  Payload dco_decode_payload(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    switch (raw[0]) {
      case 0:
        return Payload_PubkeyHash(
          pubkeyHash: dco_decode_list_prim_u_8_strict(raw[1]),
        );
      case 1:
        return Payload_ScriptHash(
          scriptHash: dco_decode_list_prim_u_8_strict(raw[1]),
        );
      case 2:
        return Payload_WitnessProgram(
          version: dco_decode_witness_version(raw[1]),
          program: dco_decode_list_prim_u_8_strict(raw[2]),
        );
      default:
        throw Exception("unreachable");
    }
  }

  @protected
  PBKDFDeriveReq dco_decode_pbkdf_derive_req(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 3)
      throw Exception('unexpected arr length: expect 3 but see ${arr.length}');
    return PBKDFDeriveReq(
      password: dco_decode_list_prim_u_8_strict(arr[0]),
      salt: dco_decode_list_prim_u_8_strict(arr[1]),
      c: dco_decode_u_32(arr[2]),
    );
  }

  @protected
  PhraseToSeedReq dco_decode_phrase_to_seed_req(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 2)
      throw Exception('unexpected arr length: expect 2 but see ${arr.length}');
    return PhraseToSeedReq(
      phrase: dco_decode_String(arr[0]),
      password: dco_decode_String(arr[1]),
    );
  }

  @protected
  RbfValue dco_decode_rbf_value(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    switch (raw[0]) {
      case 0:
        return RbfValue_RbfDefault();
      case 1:
        return RbfValue_Value(
          dco_decode_u_32(raw[1]),
        );
      default:
        throw Exception("unreachable");
    }
  }

  @protected
  RpcConfig dco_decode_rpc_config(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 6)
      throw Exception('unexpected arr length: expect 6 but see ${arr.length}');
    return RpcConfig(
      url: dco_decode_String(arr[0]),
      authCookie: dco_decode_opt_String(arr[1]),
      authUserPass: dco_decode_opt_box_autoadd_user_pass(arr[2]),
      network: dco_decode_network(arr[3]),
      walletName: dco_decode_String(arr[4]),
      syncParams: dco_decode_opt_box_autoadd_rpc_sync_params(arr[5]),
    );
  }

  @protected
  RpcSyncParams dco_decode_rpc_sync_params(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 4)
      throw Exception('unexpected arr length: expect 4 but see ${arr.length}');
    return RpcSyncParams(
      startScriptCount: dco_decode_u_64(arr[0]),
      startTime: dco_decode_u_64(arr[1]),
      forceStartTime: dco_decode_bool(arr[2]),
      pollRateSec: dco_decode_u_64(arr[3]),
    );
  }

  @protected
  SchnorrFromSeedReq dco_decode_schnorr_from_seed_req(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 1)
      throw Exception('unexpected arr length: expect 1 but see ${arr.length}');
    return SchnorrFromSeedReq(
      seed: dco_decode_list_prim_u_8_strict(arr[0]),
    );
  }

  @protected
  SchnorrIdentityExport dco_decode_schnorr_identity_export(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 2)
      throw Exception('unexpected arr length: expect 2 but see ${arr.length}');
    return SchnorrIdentityExport(
      privateKeyHash: dco_decode_list_prim_u_8_strict(arr[0]),
      publicKeyHash: dco_decode_list_prim_u_8_strict(arr[1]),
    );
  }

  @protected
  SchnorrSignWithSeedReq dco_decode_schnorr_sign_with_seed_req(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 3)
      throw Exception('unexpected arr length: expect 3 but see ${arr.length}');
    return SchnorrSignWithSeedReq(
      msg: dco_decode_list_prim_u_8_strict(arr[0]),
      seed: dco_decode_list_prim_u_8_strict(arr[1]),
      auxRand: dco_decode_opt_list_prim_u_8_strict(arr[2]),
    );
  }

  @protected
  SchnorrVerifyReq dco_decode_schnorr_verify_req(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 3)
      throw Exception('unexpected arr length: expect 3 but see ${arr.length}');
    return SchnorrVerifyReq(
      messageHash: dco_decode_list_prim_u_8_strict(arr[0]),
      signatureBytes: dco_decode_list_prim_u_8_strict(arr[1]),
      publicKeyBytes: dco_decode_list_prim_u_8_strict(arr[2]),
    );
  }

  @protected
  Script dco_decode_script(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 1)
      throw Exception('unexpected arr length: expect 1 but see ${arr.length}');
    return Script(
      internal: dco_decode_list_prim_u_8_strict(arr[0]),
    );
  }

  @protected
  ScriptAmount dco_decode_script_amount(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 2)
      throw Exception('unexpected arr length: expect 2 but see ${arr.length}');
    return ScriptAmount(
      script: dco_decode_script(arr[0]),
      amount: dco_decode_u_64(arr[1]),
    );
  }

  @protected
  ScriptDeriveReq dco_decode_script_derive_req(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 5)
      throw Exception('unexpected arr length: expect 5 but see ${arr.length}');
    return ScriptDeriveReq(
      password: dco_decode_list_prim_u_8_strict(arr[0]),
      salt: dco_decode_list_prim_u_8_strict(arr[1]),
      n: dco_decode_u_32(arr[2]),
      p: dco_decode_u_32(arr[3]),
      r: dco_decode_u_32(arr[4]),
    );
  }

  @protected
  Secp256k1FromSeedReq dco_decode_secp_256_k_1_from_seed_req(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 1)
      throw Exception('unexpected arr length: expect 1 but see ${arr.length}');
    return Secp256k1FromSeedReq(
      seed: dco_decode_list_prim_u_8_strict(arr[0]),
    );
  }

  @protected
  Secp256k1IdentityExport dco_decode_secp_256_k_1_identity_export(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 2)
      throw Exception('unexpected arr length: expect 2 but see ${arr.length}');
    return Secp256k1IdentityExport(
      privateKeyHash: dco_decode_list_prim_u_8_strict(arr[0]),
      derEncodedPublicKey: dco_decode_list_prim_u_8_strict(arr[1]),
    );
  }

  @protected
  Secp256k1RecoverReq dco_decode_secp_256_k_1_recover_req(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 3)
      throw Exception('unexpected arr length: expect 3 but see ${arr.length}');
    return Secp256k1RecoverReq(
      messagePreHashed: dco_decode_list_prim_u_8_strict(arr[0]),
      signatureBytes: dco_decode_list_prim_u_8_strict(arr[1]),
      chainId: dco_decode_opt_box_autoadd_u_8(arr[2]),
    );
  }

  @protected
  Secp256k1ShareSecretReq dco_decode_secp_256_k_1_share_secret_req(
      dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 2)
      throw Exception('unexpected arr length: expect 2 but see ${arr.length}');
    return Secp256k1ShareSecretReq(
      seed: dco_decode_list_prim_u_8_strict(arr[0]),
      publicKeyRawBytes: dco_decode_list_prim_u_8_strict(arr[1]),
    );
  }

  @protected
  Secp256k1SignWithRngReq dco_decode_secp_256_k_1_sign_with_rng_req(
      dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 2)
      throw Exception('unexpected arr length: expect 2 but see ${arr.length}');
    return Secp256k1SignWithRngReq(
      msg: dco_decode_list_prim_u_8_strict(arr[0]),
      privateBytes: dco_decode_list_prim_u_8_strict(arr[1]),
    );
  }

  @protected
  Secp256k1SignWithSeedReq dco_decode_secp_256_k_1_sign_with_seed_req(
      dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 2)
      throw Exception('unexpected arr length: expect 2 but see ${arr.length}');
    return Secp256k1SignWithSeedReq(
      msg: dco_decode_list_prim_u_8_strict(arr[0]),
      seed: dco_decode_list_prim_u_8_strict(arr[1]),
    );
  }

  @protected
  Secp256k1VerifyReq dco_decode_secp_256_k_1_verify_req(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 3)
      throw Exception('unexpected arr length: expect 3 but see ${arr.length}');
    return Secp256k1VerifyReq(
      messageHash: dco_decode_list_prim_u_8_strict(arr[0]),
      signatureBytes: dco_decode_list_prim_u_8_strict(arr[1]),
      publicKeyBytes: dco_decode_list_prim_u_8_strict(arr[2]),
    );
  }

  @protected
  SeedToKeyReq dco_decode_seed_to_key_req(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 2)
      throw Exception('unexpected arr length: expect 2 but see ${arr.length}');
    return SeedToKeyReq(
      seed: dco_decode_list_prim_u_8_strict(arr[0]),
      path: dco_decode_String(arr[1]),
    );
  }

  @protected
  SignOptions dco_decode_sign_options(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 8)
      throw Exception('unexpected arr length: expect 8 but see ${arr.length}');
    return SignOptions(
      trustWitnessUtxo: dco_decode_bool(arr[0]),
      assumeHeight: dco_decode_opt_box_autoadd_u_32(arr[1]),
      allowAllSighashes: dco_decode_bool(arr[2]),
      removePartialSigs: dco_decode_bool(arr[3]),
      tryFinalize: dco_decode_bool(arr[4]),
      finalizeMineOnly: dco_decode_bool(arr[5]),
      signWithTapInternalKey: dco_decode_bool(arr[6]),
      allowGrinding: dco_decode_bool(arr[7]),
    );
  }

  @protected
  SignatureFFI dco_decode_signature_ffi(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 2)
      throw Exception('unexpected arr length: expect 2 but see ${arr.length}');
    return SignatureFFI(
      publicKey: dco_decode_opt_list_prim_u_8_strict(arr[0]),
      signature: dco_decode_opt_list_prim_u_8_strict(arr[1]),
    );
  }

  @protected
  SledDbConfiguration dco_decode_sled_db_configuration(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 2)
      throw Exception('unexpected arr length: expect 2 but see ${arr.length}');
    return SledDbConfiguration(
      path: dco_decode_String(arr[0]),
      treeName: dco_decode_String(arr[1]),
    );
  }

  @protected
  SqliteDbConfiguration dco_decode_sqlite_db_configuration(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 1)
      throw Exception('unexpected arr length: expect 1 but see ${arr.length}');
    return SqliteDbConfiguration(
      path: dco_decode_String(arr[0]),
    );
  }

  @protected
  TransactionDetails dco_decode_transaction_details(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 6)
      throw Exception('unexpected arr length: expect 6 but see ${arr.length}');
    return TransactionDetails(
      serializedTx: dco_decode_opt_String(arr[0]),
      txid: dco_decode_String(arr[1]),
      received: dco_decode_u_64(arr[2]),
      sent: dco_decode_u_64(arr[3]),
      fee: dco_decode_opt_box_autoadd_u_64(arr[4]),
      confirmationTime: dco_decode_opt_box_autoadd_block_time(arr[5]),
    );
  }

  @protected
  TxBytes dco_decode_tx_bytes(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 2)
      throw Exception('unexpected arr length: expect 2 but see ${arr.length}');
    return TxBytes(
      txId: dco_decode_String(arr[0]),
      bytes: dco_decode_list_prim_u_8_strict(arr[1]),
    );
  }

  @protected
  TxIn dco_decode_tx_in(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 4)
      throw Exception('unexpected arr length: expect 4 but see ${arr.length}');
    return TxIn(
      previousOutput: dco_decode_out_point(arr[0]),
      scriptSig: dco_decode_script(arr[1]),
      sequence: dco_decode_u_32(arr[2]),
      witness: dco_decode_list_String(arr[3]),
    );
  }

  @protected
  TxOut dco_decode_tx_out(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 2)
      throw Exception('unexpected arr length: expect 2 but see ${arr.length}');
    return TxOut(
      value: dco_decode_u_64(arr[0]),
      scriptPubkey: dco_decode_script(arr[1]),
    );
  }

  @protected
  TxOutForeign dco_decode_tx_out_foreign(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 2)
      throw Exception('unexpected arr length: expect 2 but see ${arr.length}');
    return TxOutForeign(
      value: dco_decode_u_64(arr[0]),
      scriptPubkey: dco_decode_String(arr[1]),
    );
  }

  @protected
  int dco_decode_u_32(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw as int;
  }

  @protected
  BigInt dco_decode_u_64(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dcoDecodeU64(raw);
  }

  @protected
  int dco_decode_u_8(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw as int;
  }

  @protected
  void dco_decode_unit(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return;
  }

  @protected
  UserPass dco_decode_user_pass(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 2)
      throw Exception('unexpected arr length: expect 2 but see ${arr.length}');
    return UserPass(
      username: dco_decode_String(arr[0]),
      password: dco_decode_String(arr[1]),
    );
  }

  @protected
  BigInt dco_decode_usize(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dcoDecodeU64(raw);
  }

  @protected
  WitnessVersion dco_decode_witness_version(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return WitnessVersion.values[raw as int];
  }

  @protected
  WordCount dco_decode_word_count(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return WordCount.values[raw as int];
  }

  @protected
  AnyhowException sse_decode_AnyhowException(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var inner = sse_decode_String(deserializer);
    return AnyhowException(inner);
  }

  @protected
  BdkDescriptor sse_decode_RustOpaque_BdkDescriptor(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return BdkDescriptorImpl.frbInternalSseDecode(
        sse_decode_usize(deserializer), sse_decode_i_32(deserializer));
  }

  @protected
  BlockchainInstance sse_decode_RustOpaque_BlockchainInstance(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return BlockchainInstanceImpl.frbInternalSseDecode(
        sse_decode_usize(deserializer), sse_decode_i_32(deserializer));
  }

  @protected
  WalletInstance sse_decode_RustOpaque_WalletInstance(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return WalletInstanceImpl.frbInternalSseDecode(
        sse_decode_usize(deserializer), sse_decode_i_32(deserializer));
  }

  @protected
  String sse_decode_String(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var inner = sse_decode_list_prim_u_8_strict(deserializer);
    return utf8.decoder.convert(inner);
  }

  @protected
  AddressIndex sse_decode_address_index(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var tag_ = sse_decode_i_32(deserializer);
    switch (tag_) {
      case 0:
        return AddressIndex_NewIndex();
      case 1:
        return AddressIndex_LastUnused();
      case 2:
        var var_index = sse_decode_u_32(deserializer);
        return AddressIndex_Peek(index: var_index);
      case 3:
        var var_index = sse_decode_u_32(deserializer);
        return AddressIndex_Reset(index: var_index);
      default:
        throw UnimplementedError('');
    }
  }

  @protected
  AddressInfo sse_decode_address_info(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_index = sse_decode_u_32(deserializer);
    var var_address = sse_decode_String(deserializer);
    return AddressInfo(index: var_index, address: var_address);
  }

  @protected
  AesDecryptReq sse_decode_aes_decrypt_req(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_key = sse_decode_list_prim_u_8_strict(deserializer);
    var var_iv = sse_decode_list_prim_u_8_strict(deserializer);
    var var_cipherText = sse_decode_list_prim_u_8_strict(deserializer);
    return AesDecryptReq(key: var_key, iv: var_iv, cipherText: var_cipherText);
  }

  @protected
  AesEncryptReq sse_decode_aes_encrypt_req(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_key = sse_decode_list_prim_u_8_strict(deserializer);
    var var_iv = sse_decode_list_prim_u_8_strict(deserializer);
    var var_message = sse_decode_list_prim_u_8_strict(deserializer);
    return AesEncryptReq(key: var_key, iv: var_iv, message: var_message);
  }

  @protected
  Api sse_decode_api(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return Api();
  }

  @protected
  Balance sse_decode_balance(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_immature = sse_decode_u_64(deserializer);
    var var_trustedPending = sse_decode_u_64(deserializer);
    var var_untrustedPending = sse_decode_u_64(deserializer);
    var var_confirmed = sse_decode_u_64(deserializer);
    var var_spendable = sse_decode_u_64(deserializer);
    var var_total = sse_decode_u_64(deserializer);
    return Balance(
        immature: var_immature,
        trustedPending: var_trustedPending,
        untrustedPending: var_untrustedPending,
        confirmed: var_confirmed,
        spendable: var_spendable,
        total: var_total);
  }

  @protected
  BdkTxBuilderResult sse_decode_bdk_tx_builder_result(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_field0 = sse_decode_String(deserializer);
    var var_field1 = sse_decode_transaction_details(deserializer);
    return BdkTxBuilderResult(field0: var_field0, field1: var_field1);
  }

  @protected
  BlockTime sse_decode_block_time(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_height = sse_decode_u_32(deserializer);
    var var_timestamp = sse_decode_u_64(deserializer);
    return BlockTime(height: var_height, timestamp: var_timestamp);
  }

  @protected
  BlockchainConfig sse_decode_blockchain_config(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var tag_ = sse_decode_i_32(deserializer);
    switch (tag_) {
      case 0:
        var var_config = sse_decode_box_autoadd_electrum_config(deserializer);
        return BlockchainConfig_Electrum(config: var_config);
      case 1:
        var var_config = sse_decode_box_autoadd_esplora_config(deserializer);
        return BlockchainConfig_Esplora(config: var_config);
      case 2:
        var var_config = sse_decode_box_autoadd_rpc_config(deserializer);
        return BlockchainConfig_Rpc(config: var_config);
      default:
        throw UnimplementedError('');
    }
  }

  @protected
  BLSVerifyReq sse_decode_bls_verify_req(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_signature = sse_decode_list_prim_u_8_strict(deserializer);
    var var_message = sse_decode_list_prim_u_8_strict(deserializer);
    var var_publicKey = sse_decode_list_prim_u_8_strict(deserializer);
    return BLSVerifyReq(
        signature: var_signature,
        message: var_message,
        publicKey: var_publicKey);
  }

  @protected
  bool sse_decode_bool(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return deserializer.buffer.getUint8() != 0;
  }

  @protected
  BdkDescriptor sse_decode_box_autoadd_RustOpaque_BdkDescriptor(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_RustOpaque_BdkDescriptor(deserializer));
  }

  @protected
  AddressIndex sse_decode_box_autoadd_address_index(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_address_index(deserializer));
  }

  @protected
  AesDecryptReq sse_decode_box_autoadd_aes_decrypt_req(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_aes_decrypt_req(deserializer));
  }

  @protected
  AesEncryptReq sse_decode_box_autoadd_aes_encrypt_req(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_aes_encrypt_req(deserializer));
  }

  @protected
  BlockTime sse_decode_box_autoadd_block_time(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_block_time(deserializer));
  }

  @protected
  BlockchainConfig sse_decode_box_autoadd_blockchain_config(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_blockchain_config(deserializer));
  }

  @protected
  BLSVerifyReq sse_decode_box_autoadd_bls_verify_req(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_bls_verify_req(deserializer));
  }

  @protected
  bool sse_decode_box_autoadd_bool(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_bool(deserializer));
  }

  @protected
  DatabaseConfig sse_decode_box_autoadd_database_config(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_database_config(deserializer));
  }

  @protected
  ED25519FromSeedReq sse_decode_box_autoadd_ed_25519_from_seed_req(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_ed_25519_from_seed_req(deserializer));
  }

  @protected
  ED25519SignReq sse_decode_box_autoadd_ed_25519_sign_req(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_ed_25519_sign_req(deserializer));
  }

  @protected
  ED25519VerifyReq sse_decode_box_autoadd_ed_25519_verify_req(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_ed_25519_verify_req(deserializer));
  }

  @protected
  ElectrumConfig sse_decode_box_autoadd_electrum_config(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_electrum_config(deserializer));
  }

  @protected
  EsploraConfig sse_decode_box_autoadd_esplora_config(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_esplora_config(deserializer));
  }

  @protected
  double sse_decode_box_autoadd_f_32(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_f_32(deserializer));
  }

  @protected
  P256FromSeedReq sse_decode_box_autoadd_p_256_from_seed_req(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_p_256_from_seed_req(deserializer));
  }

  @protected
  P256ShareSecretReq sse_decode_box_autoadd_p_256_share_secret_req(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_p_256_share_secret_req(deserializer));
  }

  @protected
  P256SignWithSeedReq sse_decode_box_autoadd_p_256_sign_with_seed_req(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_p_256_sign_with_seed_req(deserializer));
  }

  @protected
  P256VerifyReq sse_decode_box_autoadd_p_256_verify_req(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_p_256_verify_req(deserializer));
  }

  @protected
  PBKDFDeriveReq sse_decode_box_autoadd_pbkdf_derive_req(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_pbkdf_derive_req(deserializer));
  }

  @protected
  PhraseToSeedReq sse_decode_box_autoadd_phrase_to_seed_req(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_phrase_to_seed_req(deserializer));
  }

  @protected
  RbfValue sse_decode_box_autoadd_rbf_value(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_rbf_value(deserializer));
  }

  @protected
  RpcConfig sse_decode_box_autoadd_rpc_config(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_rpc_config(deserializer));
  }

  @protected
  RpcSyncParams sse_decode_box_autoadd_rpc_sync_params(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_rpc_sync_params(deserializer));
  }

  @protected
  SchnorrFromSeedReq sse_decode_box_autoadd_schnorr_from_seed_req(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_schnorr_from_seed_req(deserializer));
  }

  @protected
  SchnorrSignWithSeedReq sse_decode_box_autoadd_schnorr_sign_with_seed_req(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_schnorr_sign_with_seed_req(deserializer));
  }

  @protected
  SchnorrVerifyReq sse_decode_box_autoadd_schnorr_verify_req(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_schnorr_verify_req(deserializer));
  }

  @protected
  Script sse_decode_box_autoadd_script(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_script(deserializer));
  }

  @protected
  ScriptDeriveReq sse_decode_box_autoadd_script_derive_req(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_script_derive_req(deserializer));
  }

  @protected
  Secp256k1FromSeedReq sse_decode_box_autoadd_secp_256_k_1_from_seed_req(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_secp_256_k_1_from_seed_req(deserializer));
  }

  @protected
  Secp256k1RecoverReq sse_decode_box_autoadd_secp_256_k_1_recover_req(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_secp_256_k_1_recover_req(deserializer));
  }

  @protected
  Secp256k1ShareSecretReq sse_decode_box_autoadd_secp_256_k_1_share_secret_req(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_secp_256_k_1_share_secret_req(deserializer));
  }

  @protected
  Secp256k1SignWithRngReq sse_decode_box_autoadd_secp_256_k_1_sign_with_rng_req(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_secp_256_k_1_sign_with_rng_req(deserializer));
  }

  @protected
  Secp256k1SignWithSeedReq
      sse_decode_box_autoadd_secp_256_k_1_sign_with_seed_req(
          SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_secp_256_k_1_sign_with_seed_req(deserializer));
  }

  @protected
  Secp256k1VerifyReq sse_decode_box_autoadd_secp_256_k_1_verify_req(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_secp_256_k_1_verify_req(deserializer));
  }

  @protected
  SeedToKeyReq sse_decode_box_autoadd_seed_to_key_req(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_seed_to_key_req(deserializer));
  }

  @protected
  SignOptions sse_decode_box_autoadd_sign_options(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_sign_options(deserializer));
  }

  @protected
  SledDbConfiguration sse_decode_box_autoadd_sled_db_configuration(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_sled_db_configuration(deserializer));
  }

  @protected
  SqliteDbConfiguration sse_decode_box_autoadd_sqlite_db_configuration(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_sqlite_db_configuration(deserializer));
  }

  @protected
  int sse_decode_box_autoadd_u_32(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_u_32(deserializer));
  }

  @protected
  BigInt sse_decode_box_autoadd_u_64(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_u_64(deserializer));
  }

  @protected
  int sse_decode_box_autoadd_u_8(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_u_8(deserializer));
  }

  @protected
  UserPass sse_decode_box_autoadd_user_pass(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_user_pass(deserializer));
  }

  @protected
  ChangeSpendPolicy sse_decode_change_spend_policy(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var inner = sse_decode_i_32(deserializer);
    return ChangeSpendPolicy.values[inner];
  }

  @protected
  DatabaseConfig sse_decode_database_config(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var tag_ = sse_decode_i_32(deserializer);
    switch (tag_) {
      case 0:
        return DatabaseConfig_Memory();
      case 1:
        var var_config =
            sse_decode_box_autoadd_sqlite_db_configuration(deserializer);
        return DatabaseConfig_Sqlite(config: var_config);
      case 2:
        var var_config =
            sse_decode_box_autoadd_sled_db_configuration(deserializer);
        return DatabaseConfig_Sled(config: var_config);
      default:
        throw UnimplementedError('');
    }
  }

  @protected
  ED25519FromSeedReq sse_decode_ed_25519_from_seed_req(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_seed = sse_decode_list_prim_u_8_strict(deserializer);
    return ED25519FromSeedReq(seed: var_seed);
  }

  @protected
  ED25519Res sse_decode_ed_25519_res(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_seed = sse_decode_list_prim_u_8_strict(deserializer);
    var var_publicKey = sse_decode_list_prim_u_8_strict(deserializer);
    return ED25519Res(seed: var_seed, publicKey: var_publicKey);
  }

  @protected
  ED25519SignReq sse_decode_ed_25519_sign_req(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_seed = sse_decode_list_prim_u_8_strict(deserializer);
    var var_message = sse_decode_list_prim_u_8_strict(deserializer);
    return ED25519SignReq(seed: var_seed, message: var_message);
  }

  @protected
  ED25519VerifyReq sse_decode_ed_25519_verify_req(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_sig = sse_decode_list_prim_u_8_strict(deserializer);
    var var_message = sse_decode_list_prim_u_8_strict(deserializer);
    var var_pubKey = sse_decode_list_prim_u_8_strict(deserializer);
    return ED25519VerifyReq(
        sig: var_sig, message: var_message, pubKey: var_pubKey);
  }

  @protected
  ElectrumConfig sse_decode_electrum_config(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_url = sse_decode_String(deserializer);
    var var_socks5 = sse_decode_opt_String(deserializer);
    var var_retry = sse_decode_u_8(deserializer);
    var var_timeout = sse_decode_opt_box_autoadd_u_8(deserializer);
    var var_stopGap = sse_decode_u_64(deserializer);
    var var_validateDomain = sse_decode_bool(deserializer);
    return ElectrumConfig(
        url: var_url,
        socks5: var_socks5,
        retry: var_retry,
        timeout: var_timeout,
        stopGap: var_stopGap,
        validateDomain: var_validateDomain);
  }

  @protected
  EsploraConfig sse_decode_esplora_config(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_baseUrl = sse_decode_String(deserializer);
    var var_proxy = sse_decode_opt_String(deserializer);
    var var_concurrency = sse_decode_opt_box_autoadd_u_8(deserializer);
    var var_stopGap = sse_decode_u_64(deserializer);
    var var_timeout = sse_decode_opt_box_autoadd_u_64(deserializer);
    return EsploraConfig(
        baseUrl: var_baseUrl,
        proxy: var_proxy,
        concurrency: var_concurrency,
        stopGap: var_stopGap,
        timeout: var_timeout);
  }

  @protected
  double sse_decode_f_32(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return deserializer.buffer.getFloat32();
  }

  @protected
  ForeignUtxo sse_decode_foreign_utxo(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_outpoint = sse_decode_out_point(deserializer);
    var var_txout = sse_decode_tx_out_foreign(deserializer);
    return ForeignUtxo(outpoint: var_outpoint, txout: var_txout);
  }

  @protected
  int sse_decode_i_32(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return deserializer.buffer.getInt32();
  }

  @protected
  KeyDerivedRes sse_decode_key_derived_res(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_leftBits = sse_decode_list_prim_u_8_strict(deserializer);
    var var_rightBits = sse_decode_list_prim_u_8_strict(deserializer);
    return KeyDerivedRes(leftBits: var_leftBits, rightBits: var_rightBits);
  }

  @protected
  KeychainKind sse_decode_keychain_kind(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var inner = sse_decode_i_32(deserializer);
    return KeychainKind.values[inner];
  }

  @protected
  List<String> sse_decode_list_String(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var len_ = sse_decode_i_32(deserializer);
    var ans_ = <String>[];
    for (var idx_ = 0; idx_ < len_; ++idx_) {
      ans_.add(sse_decode_String(deserializer));
    }
    return ans_;
  }

  @protected
  List<ForeignUtxo> sse_decode_list_foreign_utxo(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var len_ = sse_decode_i_32(deserializer);
    var ans_ = <ForeignUtxo>[];
    for (var idx_ = 0; idx_ < len_; ++idx_) {
      ans_.add(sse_decode_foreign_utxo(deserializer));
    }
    return ans_;
  }

  @protected
  List<LocalUtxo> sse_decode_list_local_utxo(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var len_ = sse_decode_i_32(deserializer);
    var ans_ = <LocalUtxo>[];
    for (var idx_ = 0; idx_ < len_; ++idx_) {
      ans_.add(sse_decode_local_utxo(deserializer));
    }
    return ans_;
  }

  @protected
  List<OutPoint> sse_decode_list_out_point(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var len_ = sse_decode_i_32(deserializer);
    var ans_ = <OutPoint>[];
    for (var idx_ = 0; idx_ < len_; ++idx_) {
      ans_.add(sse_decode_out_point(deserializer));
    }
    return ans_;
  }

  @protected
  List<int> sse_decode_list_prim_u_8_loose(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var len_ = sse_decode_i_32(deserializer);
    return deserializer.buffer.getUint8List(len_);
  }

  @protected
  Uint8List sse_decode_list_prim_u_8_strict(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var len_ = sse_decode_i_32(deserializer);
    return deserializer.buffer.getUint8List(len_);
  }

  @protected
  List<ScriptAmount> sse_decode_list_script_amount(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var len_ = sse_decode_i_32(deserializer);
    var ans_ = <ScriptAmount>[];
    for (var idx_ = 0; idx_ < len_; ++idx_) {
      ans_.add(sse_decode_script_amount(deserializer));
    }
    return ans_;
  }

  @protected
  List<TransactionDetails> sse_decode_list_transaction_details(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var len_ = sse_decode_i_32(deserializer);
    var ans_ = <TransactionDetails>[];
    for (var idx_ = 0; idx_ < len_; ++idx_) {
      ans_.add(sse_decode_transaction_details(deserializer));
    }
    return ans_;
  }

  @protected
  List<TxBytes> sse_decode_list_tx_bytes(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var len_ = sse_decode_i_32(deserializer);
    var ans_ = <TxBytes>[];
    for (var idx_ = 0; idx_ < len_; ++idx_) {
      ans_.add(sse_decode_tx_bytes(deserializer));
    }
    return ans_;
  }

  @protected
  List<TxIn> sse_decode_list_tx_in(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var len_ = sse_decode_i_32(deserializer);
    var ans_ = <TxIn>[];
    for (var idx_ = 0; idx_ < len_; ++idx_) {
      ans_.add(sse_decode_tx_in(deserializer));
    }
    return ans_;
  }

  @protected
  List<TxOut> sse_decode_list_tx_out(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var len_ = sse_decode_i_32(deserializer);
    var ans_ = <TxOut>[];
    for (var idx_ = 0; idx_ < len_; ++idx_) {
      ans_.add(sse_decode_tx_out(deserializer));
    }
    return ans_;
  }

  @protected
  LocalUtxo sse_decode_local_utxo(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_outpoint = sse_decode_out_point(deserializer);
    var var_txout = sse_decode_tx_out(deserializer);
    var var_isSpent = sse_decode_bool(deserializer);
    var var_keychain = sse_decode_keychain_kind(deserializer);
    return LocalUtxo(
        outpoint: var_outpoint,
        txout: var_txout,
        isSpent: var_isSpent,
        keychain: var_keychain);
  }

  @protected
  Network sse_decode_network(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var inner = sse_decode_i_32(deserializer);
    return Network.values[inner];
  }

  @protected
  String? sse_decode_opt_String(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    if (sse_decode_bool(deserializer)) {
      return (sse_decode_String(deserializer));
    } else {
      return null;
    }
  }

  @protected
  BdkDescriptor? sse_decode_opt_box_autoadd_RustOpaque_BdkDescriptor(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    if (sse_decode_bool(deserializer)) {
      return (sse_decode_box_autoadd_RustOpaque_BdkDescriptor(deserializer));
    } else {
      return null;
    }
  }

  @protected
  BlockTime? sse_decode_opt_box_autoadd_block_time(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    if (sse_decode_bool(deserializer)) {
      return (sse_decode_box_autoadd_block_time(deserializer));
    } else {
      return null;
    }
  }

  @protected
  bool? sse_decode_opt_box_autoadd_bool(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    if (sse_decode_bool(deserializer)) {
      return (sse_decode_box_autoadd_bool(deserializer));
    } else {
      return null;
    }
  }

  @protected
  double? sse_decode_opt_box_autoadd_f_32(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    if (sse_decode_bool(deserializer)) {
      return (sse_decode_box_autoadd_f_32(deserializer));
    } else {
      return null;
    }
  }

  @protected
  RbfValue? sse_decode_opt_box_autoadd_rbf_value(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    if (sse_decode_bool(deserializer)) {
      return (sse_decode_box_autoadd_rbf_value(deserializer));
    } else {
      return null;
    }
  }

  @protected
  RpcSyncParams? sse_decode_opt_box_autoadd_rpc_sync_params(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    if (sse_decode_bool(deserializer)) {
      return (sse_decode_box_autoadd_rpc_sync_params(deserializer));
    } else {
      return null;
    }
  }

  @protected
  Script? sse_decode_opt_box_autoadd_script(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    if (sse_decode_bool(deserializer)) {
      return (sse_decode_box_autoadd_script(deserializer));
    } else {
      return null;
    }
  }

  @protected
  SignOptions? sse_decode_opt_box_autoadd_sign_options(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    if (sse_decode_bool(deserializer)) {
      return (sse_decode_box_autoadd_sign_options(deserializer));
    } else {
      return null;
    }
  }

  @protected
  int? sse_decode_opt_box_autoadd_u_32(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    if (sse_decode_bool(deserializer)) {
      return (sse_decode_box_autoadd_u_32(deserializer));
    } else {
      return null;
    }
  }

  @protected
  BigInt? sse_decode_opt_box_autoadd_u_64(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    if (sse_decode_bool(deserializer)) {
      return (sse_decode_box_autoadd_u_64(deserializer));
    } else {
      return null;
    }
  }

  @protected
  int? sse_decode_opt_box_autoadd_u_8(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    if (sse_decode_bool(deserializer)) {
      return (sse_decode_box_autoadd_u_8(deserializer));
    } else {
      return null;
    }
  }

  @protected
  UserPass? sse_decode_opt_box_autoadd_user_pass(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    if (sse_decode_bool(deserializer)) {
      return (sse_decode_box_autoadd_user_pass(deserializer));
    } else {
      return null;
    }
  }

  @protected
  Uint8List? sse_decode_opt_list_prim_u_8_strict(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    if (sse_decode_bool(deserializer)) {
      return (sse_decode_list_prim_u_8_strict(deserializer));
    } else {
      return null;
    }
  }

  @protected
  OutPoint sse_decode_out_point(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_txid = sse_decode_String(deserializer);
    var var_vout = sse_decode_u_32(deserializer);
    return OutPoint(txid: var_txid, vout: var_vout);
  }

  @protected
  P256FromSeedReq sse_decode_p_256_from_seed_req(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_seed = sse_decode_list_prim_u_8_strict(deserializer);
    return P256FromSeedReq(seed: var_seed);
  }

  @protected
  P256IdentityExport sse_decode_p_256_identity_export(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_privateKeyHash = sse_decode_list_prim_u_8_strict(deserializer);
    var var_derEncodedPublicKey = sse_decode_list_prim_u_8_strict(deserializer);
    return P256IdentityExport(
        privateKeyHash: var_privateKeyHash,
        derEncodedPublicKey: var_derEncodedPublicKey);
  }

  @protected
  P256ShareSecretReq sse_decode_p_256_share_secret_req(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_seed = sse_decode_list_prim_u_8_strict(deserializer);
    var var_publicKeyRawBytes = sse_decode_list_prim_u_8_strict(deserializer);
    return P256ShareSecretReq(
        seed: var_seed, publicKeyRawBytes: var_publicKeyRawBytes);
  }

  @protected
  P256SignWithSeedReq sse_decode_p_256_sign_with_seed_req(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_msg = sse_decode_list_prim_u_8_strict(deserializer);
    var var_seed = sse_decode_list_prim_u_8_strict(deserializer);
    return P256SignWithSeedReq(msg: var_msg, seed: var_seed);
  }

  @protected
  P256VerifyReq sse_decode_p_256_verify_req(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_messageHash = sse_decode_list_prim_u_8_strict(deserializer);
    var var_signatureBytes = sse_decode_list_prim_u_8_strict(deserializer);
    var var_publicKeyBytes = sse_decode_list_prim_u_8_strict(deserializer);
    return P256VerifyReq(
        messageHash: var_messageHash,
        signatureBytes: var_signatureBytes,
        publicKeyBytes: var_publicKeyBytes);
  }

  @protected
  Payload sse_decode_payload(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var tag_ = sse_decode_i_32(deserializer);
    switch (tag_) {
      case 0:
        var var_pubkeyHash = sse_decode_list_prim_u_8_strict(deserializer);
        return Payload_PubkeyHash(pubkeyHash: var_pubkeyHash);
      case 1:
        var var_scriptHash = sse_decode_list_prim_u_8_strict(deserializer);
        return Payload_ScriptHash(scriptHash: var_scriptHash);
      case 2:
        var var_version = sse_decode_witness_version(deserializer);
        var var_program = sse_decode_list_prim_u_8_strict(deserializer);
        return Payload_WitnessProgram(
            version: var_version, program: var_program);
      default:
        throw UnimplementedError('');
    }
  }

  @protected
  PBKDFDeriveReq sse_decode_pbkdf_derive_req(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_password = sse_decode_list_prim_u_8_strict(deserializer);
    var var_salt = sse_decode_list_prim_u_8_strict(deserializer);
    var var_c = sse_decode_u_32(deserializer);
    return PBKDFDeriveReq(password: var_password, salt: var_salt, c: var_c);
  }

  @protected
  PhraseToSeedReq sse_decode_phrase_to_seed_req(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_phrase = sse_decode_String(deserializer);
    var var_password = sse_decode_String(deserializer);
    return PhraseToSeedReq(phrase: var_phrase, password: var_password);
  }

  @protected
  RbfValue sse_decode_rbf_value(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var tag_ = sse_decode_i_32(deserializer);
    switch (tag_) {
      case 0:
        return RbfValue_RbfDefault();
      case 1:
        var var_field0 = sse_decode_u_32(deserializer);
        return RbfValue_Value(var_field0);
      default:
        throw UnimplementedError('');
    }
  }

  @protected
  RpcConfig sse_decode_rpc_config(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_url = sse_decode_String(deserializer);
    var var_authCookie = sse_decode_opt_String(deserializer);
    var var_authUserPass = sse_decode_opt_box_autoadd_user_pass(deserializer);
    var var_network = sse_decode_network(deserializer);
    var var_walletName = sse_decode_String(deserializer);
    var var_syncParams =
        sse_decode_opt_box_autoadd_rpc_sync_params(deserializer);
    return RpcConfig(
        url: var_url,
        authCookie: var_authCookie,
        authUserPass: var_authUserPass,
        network: var_network,
        walletName: var_walletName,
        syncParams: var_syncParams);
  }

  @protected
  RpcSyncParams sse_decode_rpc_sync_params(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_startScriptCount = sse_decode_u_64(deserializer);
    var var_startTime = sse_decode_u_64(deserializer);
    var var_forceStartTime = sse_decode_bool(deserializer);
    var var_pollRateSec = sse_decode_u_64(deserializer);
    return RpcSyncParams(
        startScriptCount: var_startScriptCount,
        startTime: var_startTime,
        forceStartTime: var_forceStartTime,
        pollRateSec: var_pollRateSec);
  }

  @protected
  SchnorrFromSeedReq sse_decode_schnorr_from_seed_req(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_seed = sse_decode_list_prim_u_8_strict(deserializer);
    return SchnorrFromSeedReq(seed: var_seed);
  }

  @protected
  SchnorrIdentityExport sse_decode_schnorr_identity_export(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_privateKeyHash = sse_decode_list_prim_u_8_strict(deserializer);
    var var_publicKeyHash = sse_decode_list_prim_u_8_strict(deserializer);
    return SchnorrIdentityExport(
        privateKeyHash: var_privateKeyHash, publicKeyHash: var_publicKeyHash);
  }

  @protected
  SchnorrSignWithSeedReq sse_decode_schnorr_sign_with_seed_req(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_msg = sse_decode_list_prim_u_8_strict(deserializer);
    var var_seed = sse_decode_list_prim_u_8_strict(deserializer);
    var var_auxRand = sse_decode_opt_list_prim_u_8_strict(deserializer);
    return SchnorrSignWithSeedReq(
        msg: var_msg, seed: var_seed, auxRand: var_auxRand);
  }

  @protected
  SchnorrVerifyReq sse_decode_schnorr_verify_req(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_messageHash = sse_decode_list_prim_u_8_strict(deserializer);
    var var_signatureBytes = sse_decode_list_prim_u_8_strict(deserializer);
    var var_publicKeyBytes = sse_decode_list_prim_u_8_strict(deserializer);
    return SchnorrVerifyReq(
        messageHash: var_messageHash,
        signatureBytes: var_signatureBytes,
        publicKeyBytes: var_publicKeyBytes);
  }

  @protected
  Script sse_decode_script(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_internal = sse_decode_list_prim_u_8_strict(deserializer);
    return Script(internal: var_internal);
  }

  @protected
  ScriptAmount sse_decode_script_amount(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_script = sse_decode_script(deserializer);
    var var_amount = sse_decode_u_64(deserializer);
    return ScriptAmount(script: var_script, amount: var_amount);
  }

  @protected
  ScriptDeriveReq sse_decode_script_derive_req(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_password = sse_decode_list_prim_u_8_strict(deserializer);
    var var_salt = sse_decode_list_prim_u_8_strict(deserializer);
    var var_n = sse_decode_u_32(deserializer);
    var var_p = sse_decode_u_32(deserializer);
    var var_r = sse_decode_u_32(deserializer);
    return ScriptDeriveReq(
        password: var_password, salt: var_salt, n: var_n, p: var_p, r: var_r);
  }

  @protected
  Secp256k1FromSeedReq sse_decode_secp_256_k_1_from_seed_req(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_seed = sse_decode_list_prim_u_8_strict(deserializer);
    return Secp256k1FromSeedReq(seed: var_seed);
  }

  @protected
  Secp256k1IdentityExport sse_decode_secp_256_k_1_identity_export(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_privateKeyHash = sse_decode_list_prim_u_8_strict(deserializer);
    var var_derEncodedPublicKey = sse_decode_list_prim_u_8_strict(deserializer);
    return Secp256k1IdentityExport(
        privateKeyHash: var_privateKeyHash,
        derEncodedPublicKey: var_derEncodedPublicKey);
  }

  @protected
  Secp256k1RecoverReq sse_decode_secp_256_k_1_recover_req(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_messagePreHashed = sse_decode_list_prim_u_8_strict(deserializer);
    var var_signatureBytes = sse_decode_list_prim_u_8_strict(deserializer);
    var var_chainId = sse_decode_opt_box_autoadd_u_8(deserializer);
    return Secp256k1RecoverReq(
        messagePreHashed: var_messagePreHashed,
        signatureBytes: var_signatureBytes,
        chainId: var_chainId);
  }

  @protected
  Secp256k1ShareSecretReq sse_decode_secp_256_k_1_share_secret_req(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_seed = sse_decode_list_prim_u_8_strict(deserializer);
    var var_publicKeyRawBytes = sse_decode_list_prim_u_8_strict(deserializer);
    return Secp256k1ShareSecretReq(
        seed: var_seed, publicKeyRawBytes: var_publicKeyRawBytes);
  }

  @protected
  Secp256k1SignWithRngReq sse_decode_secp_256_k_1_sign_with_rng_req(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_msg = sse_decode_list_prim_u_8_strict(deserializer);
    var var_privateBytes = sse_decode_list_prim_u_8_strict(deserializer);
    return Secp256k1SignWithRngReq(
        msg: var_msg, privateBytes: var_privateBytes);
  }

  @protected
  Secp256k1SignWithSeedReq sse_decode_secp_256_k_1_sign_with_seed_req(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_msg = sse_decode_list_prim_u_8_strict(deserializer);
    var var_seed = sse_decode_list_prim_u_8_strict(deserializer);
    return Secp256k1SignWithSeedReq(msg: var_msg, seed: var_seed);
  }

  @protected
  Secp256k1VerifyReq sse_decode_secp_256_k_1_verify_req(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_messageHash = sse_decode_list_prim_u_8_strict(deserializer);
    var var_signatureBytes = sse_decode_list_prim_u_8_strict(deserializer);
    var var_publicKeyBytes = sse_decode_list_prim_u_8_strict(deserializer);
    return Secp256k1VerifyReq(
        messageHash: var_messageHash,
        signatureBytes: var_signatureBytes,
        publicKeyBytes: var_publicKeyBytes);
  }

  @protected
  SeedToKeyReq sse_decode_seed_to_key_req(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_seed = sse_decode_list_prim_u_8_strict(deserializer);
    var var_path = sse_decode_String(deserializer);
    return SeedToKeyReq(seed: var_seed, path: var_path);
  }

  @protected
  SignOptions sse_decode_sign_options(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_trustWitnessUtxo = sse_decode_bool(deserializer);
    var var_assumeHeight = sse_decode_opt_box_autoadd_u_32(deserializer);
    var var_allowAllSighashes = sse_decode_bool(deserializer);
    var var_removePartialSigs = sse_decode_bool(deserializer);
    var var_tryFinalize = sse_decode_bool(deserializer);
    var var_finalizeMineOnly = sse_decode_bool(deserializer);
    var var_signWithTapInternalKey = sse_decode_bool(deserializer);
    var var_allowGrinding = sse_decode_bool(deserializer);
    return SignOptions(
        trustWitnessUtxo: var_trustWitnessUtxo,
        assumeHeight: var_assumeHeight,
        allowAllSighashes: var_allowAllSighashes,
        removePartialSigs: var_removePartialSigs,
        tryFinalize: var_tryFinalize,
        finalizeMineOnly: var_finalizeMineOnly,
        signWithTapInternalKey: var_signWithTapInternalKey,
        allowGrinding: var_allowGrinding);
  }

  @protected
  SignatureFFI sse_decode_signature_ffi(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_publicKey = sse_decode_opt_list_prim_u_8_strict(deserializer);
    var var_signature = sse_decode_opt_list_prim_u_8_strict(deserializer);
    return SignatureFFI(publicKey: var_publicKey, signature: var_signature);
  }

  @protected
  SledDbConfiguration sse_decode_sled_db_configuration(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_path = sse_decode_String(deserializer);
    var var_treeName = sse_decode_String(deserializer);
    return SledDbConfiguration(path: var_path, treeName: var_treeName);
  }

  @protected
  SqliteDbConfiguration sse_decode_sqlite_db_configuration(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_path = sse_decode_String(deserializer);
    return SqliteDbConfiguration(path: var_path);
  }

  @protected
  TransactionDetails sse_decode_transaction_details(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_serializedTx = sse_decode_opt_String(deserializer);
    var var_txid = sse_decode_String(deserializer);
    var var_received = sse_decode_u_64(deserializer);
    var var_sent = sse_decode_u_64(deserializer);
    var var_fee = sse_decode_opt_box_autoadd_u_64(deserializer);
    var var_confirmationTime =
        sse_decode_opt_box_autoadd_block_time(deserializer);
    return TransactionDetails(
        serializedTx: var_serializedTx,
        txid: var_txid,
        received: var_received,
        sent: var_sent,
        fee: var_fee,
        confirmationTime: var_confirmationTime);
  }

  @protected
  TxBytes sse_decode_tx_bytes(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_txId = sse_decode_String(deserializer);
    var var_bytes = sse_decode_list_prim_u_8_strict(deserializer);
    return TxBytes(txId: var_txId, bytes: var_bytes);
  }

  @protected
  TxIn sse_decode_tx_in(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_previousOutput = sse_decode_out_point(deserializer);
    var var_scriptSig = sse_decode_script(deserializer);
    var var_sequence = sse_decode_u_32(deserializer);
    var var_witness = sse_decode_list_String(deserializer);
    return TxIn(
        previousOutput: var_previousOutput,
        scriptSig: var_scriptSig,
        sequence: var_sequence,
        witness: var_witness);
  }

  @protected
  TxOut sse_decode_tx_out(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_value = sse_decode_u_64(deserializer);
    var var_scriptPubkey = sse_decode_script(deserializer);
    return TxOut(value: var_value, scriptPubkey: var_scriptPubkey);
  }

  @protected
  TxOutForeign sse_decode_tx_out_foreign(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_value = sse_decode_u_64(deserializer);
    var var_scriptPubkey = sse_decode_String(deserializer);
    return TxOutForeign(value: var_value, scriptPubkey: var_scriptPubkey);
  }

  @protected
  int sse_decode_u_32(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return deserializer.buffer.getUint32();
  }

  @protected
  BigInt sse_decode_u_64(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return deserializer.buffer.getBigUint64();
  }

  @protected
  int sse_decode_u_8(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return deserializer.buffer.getUint8();
  }

  @protected
  void sse_decode_unit(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
  }

  @protected
  UserPass sse_decode_user_pass(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_username = sse_decode_String(deserializer);
    var var_password = sse_decode_String(deserializer);
    return UserPass(username: var_username, password: var_password);
  }

  @protected
  BigInt sse_decode_usize(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return deserializer.buffer.getBigUint64();
  }

  @protected
  WitnessVersion sse_decode_witness_version(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var inner = sse_decode_i_32(deserializer);
    return WitnessVersion.values[inner];
  }

  @protected
  WordCount sse_decode_word_count(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var inner = sse_decode_i_32(deserializer);
    return WordCount.values[inner];
  }

  @protected
  void sse_encode_AnyhowException(
      AnyhowException self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_String(self.message, serializer);
  }

  @protected
  void sse_encode_RustOpaque_BdkDescriptor(
      BdkDescriptor self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_usize(
        (self as BdkDescriptorImpl).frbInternalSseEncode(move: null),
        serializer);
  }

  @protected
  void sse_encode_RustOpaque_BlockchainInstance(
      BlockchainInstance self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_usize(
        (self as BlockchainInstanceImpl).frbInternalSseEncode(move: null),
        serializer);
  }

  @protected
  void sse_encode_RustOpaque_WalletInstance(
      WalletInstance self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_usize(
        (self as WalletInstanceImpl).frbInternalSseEncode(move: null),
        serializer);
  }

  @protected
  void sse_encode_String(String self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_list_prim_u_8_strict(utf8.encoder.convert(self), serializer);
  }

  @protected
  void sse_encode_address_index(AddressIndex self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    switch (self) {
      case AddressIndex_NewIndex():
        sse_encode_i_32(0, serializer);
      case AddressIndex_LastUnused():
        sse_encode_i_32(1, serializer);
      case AddressIndex_Peek(index: final index):
        sse_encode_i_32(2, serializer);
        sse_encode_u_32(index, serializer);
      case AddressIndex_Reset(index: final index):
        sse_encode_i_32(3, serializer);
        sse_encode_u_32(index, serializer);
      default:
        throw UnimplementedError('');
    }
  }

  @protected
  void sse_encode_address_info(AddressInfo self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_u_32(self.index, serializer);
    sse_encode_String(self.address, serializer);
  }

  @protected
  void sse_encode_aes_decrypt_req(
      AesDecryptReq self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_list_prim_u_8_strict(self.key, serializer);
    sse_encode_list_prim_u_8_strict(self.iv, serializer);
    sse_encode_list_prim_u_8_strict(self.cipherText, serializer);
  }

  @protected
  void sse_encode_aes_encrypt_req(
      AesEncryptReq self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_list_prim_u_8_strict(self.key, serializer);
    sse_encode_list_prim_u_8_strict(self.iv, serializer);
    sse_encode_list_prim_u_8_strict(self.message, serializer);
  }

  @protected
  void sse_encode_api(Api self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
  }

  @protected
  void sse_encode_balance(Balance self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_u_64(self.immature, serializer);
    sse_encode_u_64(self.trustedPending, serializer);
    sse_encode_u_64(self.untrustedPending, serializer);
    sse_encode_u_64(self.confirmed, serializer);
    sse_encode_u_64(self.spendable, serializer);
    sse_encode_u_64(self.total, serializer);
  }

  @protected
  void sse_encode_bdk_tx_builder_result(
      BdkTxBuilderResult self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_String(self.field0, serializer);
    sse_encode_transaction_details(self.field1, serializer);
  }

  @protected
  void sse_encode_block_time(BlockTime self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_u_32(self.height, serializer);
    sse_encode_u_64(self.timestamp, serializer);
  }

  @protected
  void sse_encode_blockchain_config(
      BlockchainConfig self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    switch (self) {
      case BlockchainConfig_Electrum(config: final config):
        sse_encode_i_32(0, serializer);
        sse_encode_box_autoadd_electrum_config(config, serializer);
      case BlockchainConfig_Esplora(config: final config):
        sse_encode_i_32(1, serializer);
        sse_encode_box_autoadd_esplora_config(config, serializer);
      case BlockchainConfig_Rpc(config: final config):
        sse_encode_i_32(2, serializer);
        sse_encode_box_autoadd_rpc_config(config, serializer);
      default:
        throw UnimplementedError('');
    }
  }

  @protected
  void sse_encode_bls_verify_req(BLSVerifyReq self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_list_prim_u_8_strict(self.signature, serializer);
    sse_encode_list_prim_u_8_strict(self.message, serializer);
    sse_encode_list_prim_u_8_strict(self.publicKey, serializer);
  }

  @protected
  void sse_encode_bool(bool self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    serializer.buffer.putUint8(self ? 1 : 0);
  }

  @protected
  void sse_encode_box_autoadd_RustOpaque_BdkDescriptor(
      BdkDescriptor self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_RustOpaque_BdkDescriptor(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_address_index(
      AddressIndex self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_address_index(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_aes_decrypt_req(
      AesDecryptReq self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_aes_decrypt_req(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_aes_encrypt_req(
      AesEncryptReq self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_aes_encrypt_req(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_block_time(
      BlockTime self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_block_time(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_blockchain_config(
      BlockchainConfig self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_blockchain_config(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_bls_verify_req(
      BLSVerifyReq self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_bls_verify_req(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_bool(bool self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_bool(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_database_config(
      DatabaseConfig self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_database_config(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_ed_25519_from_seed_req(
      ED25519FromSeedReq self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_ed_25519_from_seed_req(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_ed_25519_sign_req(
      ED25519SignReq self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_ed_25519_sign_req(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_ed_25519_verify_req(
      ED25519VerifyReq self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_ed_25519_verify_req(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_electrum_config(
      ElectrumConfig self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_electrum_config(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_esplora_config(
      EsploraConfig self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_esplora_config(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_f_32(double self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_f_32(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_p_256_from_seed_req(
      P256FromSeedReq self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_p_256_from_seed_req(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_p_256_share_secret_req(
      P256ShareSecretReq self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_p_256_share_secret_req(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_p_256_sign_with_seed_req(
      P256SignWithSeedReq self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_p_256_sign_with_seed_req(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_p_256_verify_req(
      P256VerifyReq self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_p_256_verify_req(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_pbkdf_derive_req(
      PBKDFDeriveReq self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_pbkdf_derive_req(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_phrase_to_seed_req(
      PhraseToSeedReq self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_phrase_to_seed_req(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_rbf_value(
      RbfValue self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_rbf_value(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_rpc_config(
      RpcConfig self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_rpc_config(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_rpc_sync_params(
      RpcSyncParams self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_rpc_sync_params(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_schnorr_from_seed_req(
      SchnorrFromSeedReq self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_schnorr_from_seed_req(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_schnorr_sign_with_seed_req(
      SchnorrSignWithSeedReq self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_schnorr_sign_with_seed_req(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_schnorr_verify_req(
      SchnorrVerifyReq self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_schnorr_verify_req(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_script(Script self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_script(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_script_derive_req(
      ScriptDeriveReq self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_script_derive_req(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_secp_256_k_1_from_seed_req(
      Secp256k1FromSeedReq self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_secp_256_k_1_from_seed_req(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_secp_256_k_1_recover_req(
      Secp256k1RecoverReq self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_secp_256_k_1_recover_req(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_secp_256_k_1_share_secret_req(
      Secp256k1ShareSecretReq self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_secp_256_k_1_share_secret_req(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_secp_256_k_1_sign_with_rng_req(
      Secp256k1SignWithRngReq self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_secp_256_k_1_sign_with_rng_req(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_secp_256_k_1_sign_with_seed_req(
      Secp256k1SignWithSeedReq self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_secp_256_k_1_sign_with_seed_req(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_secp_256_k_1_verify_req(
      Secp256k1VerifyReq self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_secp_256_k_1_verify_req(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_seed_to_key_req(
      SeedToKeyReq self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_seed_to_key_req(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_sign_options(
      SignOptions self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_sign_options(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_sled_db_configuration(
      SledDbConfiguration self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_sled_db_configuration(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_sqlite_db_configuration(
      SqliteDbConfiguration self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_sqlite_db_configuration(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_u_32(int self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_u_32(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_u_64(BigInt self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_u_64(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_u_8(int self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_u_8(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_user_pass(
      UserPass self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_user_pass(self, serializer);
  }

  @protected
  void sse_encode_change_spend_policy(
      ChangeSpendPolicy self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.index, serializer);
  }

  @protected
  void sse_encode_database_config(
      DatabaseConfig self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    switch (self) {
      case DatabaseConfig_Memory():
        sse_encode_i_32(0, serializer);
      case DatabaseConfig_Sqlite(config: final config):
        sse_encode_i_32(1, serializer);
        sse_encode_box_autoadd_sqlite_db_configuration(config, serializer);
      case DatabaseConfig_Sled(config: final config):
        sse_encode_i_32(2, serializer);
        sse_encode_box_autoadd_sled_db_configuration(config, serializer);
      default:
        throw UnimplementedError('');
    }
  }

  @protected
  void sse_encode_ed_25519_from_seed_req(
      ED25519FromSeedReq self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_list_prim_u_8_strict(self.seed, serializer);
  }

  @protected
  void sse_encode_ed_25519_res(ED25519Res self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_list_prim_u_8_strict(self.seed, serializer);
    sse_encode_list_prim_u_8_strict(self.publicKey, serializer);
  }

  @protected
  void sse_encode_ed_25519_sign_req(
      ED25519SignReq self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_list_prim_u_8_strict(self.seed, serializer);
    sse_encode_list_prim_u_8_strict(self.message, serializer);
  }

  @protected
  void sse_encode_ed_25519_verify_req(
      ED25519VerifyReq self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_list_prim_u_8_strict(self.sig, serializer);
    sse_encode_list_prim_u_8_strict(self.message, serializer);
    sse_encode_list_prim_u_8_strict(self.pubKey, serializer);
  }

  @protected
  void sse_encode_electrum_config(
      ElectrumConfig self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_String(self.url, serializer);
    sse_encode_opt_String(self.socks5, serializer);
    sse_encode_u_8(self.retry, serializer);
    sse_encode_opt_box_autoadd_u_8(self.timeout, serializer);
    sse_encode_u_64(self.stopGap, serializer);
    sse_encode_bool(self.validateDomain, serializer);
  }

  @protected
  void sse_encode_esplora_config(EsploraConfig self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_String(self.baseUrl, serializer);
    sse_encode_opt_String(self.proxy, serializer);
    sse_encode_opt_box_autoadd_u_8(self.concurrency, serializer);
    sse_encode_u_64(self.stopGap, serializer);
    sse_encode_opt_box_autoadd_u_64(self.timeout, serializer);
  }

  @protected
  void sse_encode_f_32(double self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    serializer.buffer.putFloat32(self);
  }

  @protected
  void sse_encode_foreign_utxo(ForeignUtxo self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_out_point(self.outpoint, serializer);
    sse_encode_tx_out_foreign(self.txout, serializer);
  }

  @protected
  void sse_encode_i_32(int self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    serializer.buffer.putInt32(self);
  }

  @protected
  void sse_encode_key_derived_res(
      KeyDerivedRes self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_list_prim_u_8_strict(self.leftBits, serializer);
    sse_encode_list_prim_u_8_strict(self.rightBits, serializer);
  }

  @protected
  void sse_encode_keychain_kind(KeychainKind self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.index, serializer);
  }

  @protected
  void sse_encode_list_String(List<String> self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.length, serializer);
    for (final item in self) {
      sse_encode_String(item, serializer);
    }
  }

  @protected
  void sse_encode_list_foreign_utxo(
      List<ForeignUtxo> self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.length, serializer);
    for (final item in self) {
      sse_encode_foreign_utxo(item, serializer);
    }
  }

  @protected
  void sse_encode_list_local_utxo(
      List<LocalUtxo> self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.length, serializer);
    for (final item in self) {
      sse_encode_local_utxo(item, serializer);
    }
  }

  @protected
  void sse_encode_list_out_point(
      List<OutPoint> self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.length, serializer);
    for (final item in self) {
      sse_encode_out_point(item, serializer);
    }
  }

  @protected
  void sse_encode_list_prim_u_8_loose(
      List<int> self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.length, serializer);
    serializer.buffer
        .putUint8List(self is Uint8List ? self : Uint8List.fromList(self));
  }

  @protected
  void sse_encode_list_prim_u_8_strict(
      Uint8List self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.length, serializer);
    serializer.buffer.putUint8List(self);
  }

  @protected
  void sse_encode_list_script_amount(
      List<ScriptAmount> self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.length, serializer);
    for (final item in self) {
      sse_encode_script_amount(item, serializer);
    }
  }

  @protected
  void sse_encode_list_transaction_details(
      List<TransactionDetails> self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.length, serializer);
    for (final item in self) {
      sse_encode_transaction_details(item, serializer);
    }
  }

  @protected
  void sse_encode_list_tx_bytes(List<TxBytes> self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.length, serializer);
    for (final item in self) {
      sse_encode_tx_bytes(item, serializer);
    }
  }

  @protected
  void sse_encode_list_tx_in(List<TxIn> self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.length, serializer);
    for (final item in self) {
      sse_encode_tx_in(item, serializer);
    }
  }

  @protected
  void sse_encode_list_tx_out(List<TxOut> self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.length, serializer);
    for (final item in self) {
      sse_encode_tx_out(item, serializer);
    }
  }

  @protected
  void sse_encode_local_utxo(LocalUtxo self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_out_point(self.outpoint, serializer);
    sse_encode_tx_out(self.txout, serializer);
    sse_encode_bool(self.isSpent, serializer);
    sse_encode_keychain_kind(self.keychain, serializer);
  }

  @protected
  void sse_encode_network(Network self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.index, serializer);
  }

  @protected
  void sse_encode_opt_String(String? self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    sse_encode_bool(self != null, serializer);
    if (self != null) {
      sse_encode_String(self, serializer);
    }
  }

  @protected
  void sse_encode_opt_box_autoadd_RustOpaque_BdkDescriptor(
      BdkDescriptor? self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    sse_encode_bool(self != null, serializer);
    if (self != null) {
      sse_encode_box_autoadd_RustOpaque_BdkDescriptor(self, serializer);
    }
  }

  @protected
  void sse_encode_opt_box_autoadd_block_time(
      BlockTime? self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    sse_encode_bool(self != null, serializer);
    if (self != null) {
      sse_encode_box_autoadd_block_time(self, serializer);
    }
  }

  @protected
  void sse_encode_opt_box_autoadd_bool(bool? self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    sse_encode_bool(self != null, serializer);
    if (self != null) {
      sse_encode_box_autoadd_bool(self, serializer);
    }
  }

  @protected
  void sse_encode_opt_box_autoadd_f_32(double? self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    sse_encode_bool(self != null, serializer);
    if (self != null) {
      sse_encode_box_autoadd_f_32(self, serializer);
    }
  }

  @protected
  void sse_encode_opt_box_autoadd_rbf_value(
      RbfValue? self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    sse_encode_bool(self != null, serializer);
    if (self != null) {
      sse_encode_box_autoadd_rbf_value(self, serializer);
    }
  }

  @protected
  void sse_encode_opt_box_autoadd_rpc_sync_params(
      RpcSyncParams? self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    sse_encode_bool(self != null, serializer);
    if (self != null) {
      sse_encode_box_autoadd_rpc_sync_params(self, serializer);
    }
  }

  @protected
  void sse_encode_opt_box_autoadd_script(
      Script? self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    sse_encode_bool(self != null, serializer);
    if (self != null) {
      sse_encode_box_autoadd_script(self, serializer);
    }
  }

  @protected
  void sse_encode_opt_box_autoadd_sign_options(
      SignOptions? self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    sse_encode_bool(self != null, serializer);
    if (self != null) {
      sse_encode_box_autoadd_sign_options(self, serializer);
    }
  }

  @protected
  void sse_encode_opt_box_autoadd_u_32(int? self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    sse_encode_bool(self != null, serializer);
    if (self != null) {
      sse_encode_box_autoadd_u_32(self, serializer);
    }
  }

  @protected
  void sse_encode_opt_box_autoadd_u_64(BigInt? self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    sse_encode_bool(self != null, serializer);
    if (self != null) {
      sse_encode_box_autoadd_u_64(self, serializer);
    }
  }

  @protected
  void sse_encode_opt_box_autoadd_u_8(int? self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    sse_encode_bool(self != null, serializer);
    if (self != null) {
      sse_encode_box_autoadd_u_8(self, serializer);
    }
  }

  @protected
  void sse_encode_opt_box_autoadd_user_pass(
      UserPass? self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    sse_encode_bool(self != null, serializer);
    if (self != null) {
      sse_encode_box_autoadd_user_pass(self, serializer);
    }
  }

  @protected
  void sse_encode_opt_list_prim_u_8_strict(
      Uint8List? self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    sse_encode_bool(self != null, serializer);
    if (self != null) {
      sse_encode_list_prim_u_8_strict(self, serializer);
    }
  }

  @protected
  void sse_encode_out_point(OutPoint self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_String(self.txid, serializer);
    sse_encode_u_32(self.vout, serializer);
  }

  @protected
  void sse_encode_p_256_from_seed_req(
      P256FromSeedReq self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_list_prim_u_8_strict(self.seed, serializer);
  }

  @protected
  void sse_encode_p_256_identity_export(
      P256IdentityExport self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_list_prim_u_8_strict(self.privateKeyHash, serializer);
    sse_encode_list_prim_u_8_strict(self.derEncodedPublicKey, serializer);
  }

  @protected
  void sse_encode_p_256_share_secret_req(
      P256ShareSecretReq self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_list_prim_u_8_strict(self.seed, serializer);
    sse_encode_list_prim_u_8_strict(self.publicKeyRawBytes, serializer);
  }

  @protected
  void sse_encode_p_256_sign_with_seed_req(
      P256SignWithSeedReq self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_list_prim_u_8_strict(self.msg, serializer);
    sse_encode_list_prim_u_8_strict(self.seed, serializer);
  }

  @protected
  void sse_encode_p_256_verify_req(
      P256VerifyReq self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_list_prim_u_8_strict(self.messageHash, serializer);
    sse_encode_list_prim_u_8_strict(self.signatureBytes, serializer);
    sse_encode_list_prim_u_8_strict(self.publicKeyBytes, serializer);
  }

  @protected
  void sse_encode_payload(Payload self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    switch (self) {
      case Payload_PubkeyHash(pubkeyHash: final pubkeyHash):
        sse_encode_i_32(0, serializer);
        sse_encode_list_prim_u_8_strict(pubkeyHash, serializer);
      case Payload_ScriptHash(scriptHash: final scriptHash):
        sse_encode_i_32(1, serializer);
        sse_encode_list_prim_u_8_strict(scriptHash, serializer);
      case Payload_WitnessProgram(
          version: final version,
          program: final program
        ):
        sse_encode_i_32(2, serializer);
        sse_encode_witness_version(version, serializer);
        sse_encode_list_prim_u_8_strict(program, serializer);
      default:
        throw UnimplementedError('');
    }
  }

  @protected
  void sse_encode_pbkdf_derive_req(
      PBKDFDeriveReq self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_list_prim_u_8_strict(self.password, serializer);
    sse_encode_list_prim_u_8_strict(self.salt, serializer);
    sse_encode_u_32(self.c, serializer);
  }

  @protected
  void sse_encode_phrase_to_seed_req(
      PhraseToSeedReq self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_String(self.phrase, serializer);
    sse_encode_String(self.password, serializer);
  }

  @protected
  void sse_encode_rbf_value(RbfValue self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    switch (self) {
      case RbfValue_RbfDefault():
        sse_encode_i_32(0, serializer);
      case RbfValue_Value(field0: final field0):
        sse_encode_i_32(1, serializer);
        sse_encode_u_32(field0, serializer);
      default:
        throw UnimplementedError('');
    }
  }

  @protected
  void sse_encode_rpc_config(RpcConfig self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_String(self.url, serializer);
    sse_encode_opt_String(self.authCookie, serializer);
    sse_encode_opt_box_autoadd_user_pass(self.authUserPass, serializer);
    sse_encode_network(self.network, serializer);
    sse_encode_String(self.walletName, serializer);
    sse_encode_opt_box_autoadd_rpc_sync_params(self.syncParams, serializer);
  }

  @protected
  void sse_encode_rpc_sync_params(
      RpcSyncParams self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_u_64(self.startScriptCount, serializer);
    sse_encode_u_64(self.startTime, serializer);
    sse_encode_bool(self.forceStartTime, serializer);
    sse_encode_u_64(self.pollRateSec, serializer);
  }

  @protected
  void sse_encode_schnorr_from_seed_req(
      SchnorrFromSeedReq self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_list_prim_u_8_strict(self.seed, serializer);
  }

  @protected
  void sse_encode_schnorr_identity_export(
      SchnorrIdentityExport self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_list_prim_u_8_strict(self.privateKeyHash, serializer);
    sse_encode_list_prim_u_8_strict(self.publicKeyHash, serializer);
  }

  @protected
  void sse_encode_schnorr_sign_with_seed_req(
      SchnorrSignWithSeedReq self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_list_prim_u_8_strict(self.msg, serializer);
    sse_encode_list_prim_u_8_strict(self.seed, serializer);
    sse_encode_opt_list_prim_u_8_strict(self.auxRand, serializer);
  }

  @protected
  void sse_encode_schnorr_verify_req(
      SchnorrVerifyReq self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_list_prim_u_8_strict(self.messageHash, serializer);
    sse_encode_list_prim_u_8_strict(self.signatureBytes, serializer);
    sse_encode_list_prim_u_8_strict(self.publicKeyBytes, serializer);
  }

  @protected
  void sse_encode_script(Script self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_list_prim_u_8_strict(self.internal, serializer);
  }

  @protected
  void sse_encode_script_amount(ScriptAmount self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_script(self.script, serializer);
    sse_encode_u_64(self.amount, serializer);
  }

  @protected
  void sse_encode_script_derive_req(
      ScriptDeriveReq self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_list_prim_u_8_strict(self.password, serializer);
    sse_encode_list_prim_u_8_strict(self.salt, serializer);
    sse_encode_u_32(self.n, serializer);
    sse_encode_u_32(self.p, serializer);
    sse_encode_u_32(self.r, serializer);
  }

  @protected
  void sse_encode_secp_256_k_1_from_seed_req(
      Secp256k1FromSeedReq self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_list_prim_u_8_strict(self.seed, serializer);
  }

  @protected
  void sse_encode_secp_256_k_1_identity_export(
      Secp256k1IdentityExport self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_list_prim_u_8_strict(self.privateKeyHash, serializer);
    sse_encode_list_prim_u_8_strict(self.derEncodedPublicKey, serializer);
  }

  @protected
  void sse_encode_secp_256_k_1_recover_req(
      Secp256k1RecoverReq self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_list_prim_u_8_strict(self.messagePreHashed, serializer);
    sse_encode_list_prim_u_8_strict(self.signatureBytes, serializer);
    sse_encode_opt_box_autoadd_u_8(self.chainId, serializer);
  }

  @protected
  void sse_encode_secp_256_k_1_share_secret_req(
      Secp256k1ShareSecretReq self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_list_prim_u_8_strict(self.seed, serializer);
    sse_encode_list_prim_u_8_strict(self.publicKeyRawBytes, serializer);
  }

  @protected
  void sse_encode_secp_256_k_1_sign_with_rng_req(
      Secp256k1SignWithRngReq self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_list_prim_u_8_strict(self.msg, serializer);
    sse_encode_list_prim_u_8_strict(self.privateBytes, serializer);
  }

  @protected
  void sse_encode_secp_256_k_1_sign_with_seed_req(
      Secp256k1SignWithSeedReq self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_list_prim_u_8_strict(self.msg, serializer);
    sse_encode_list_prim_u_8_strict(self.seed, serializer);
  }

  @protected
  void sse_encode_secp_256_k_1_verify_req(
      Secp256k1VerifyReq self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_list_prim_u_8_strict(self.messageHash, serializer);
    sse_encode_list_prim_u_8_strict(self.signatureBytes, serializer);
    sse_encode_list_prim_u_8_strict(self.publicKeyBytes, serializer);
  }

  @protected
  void sse_encode_seed_to_key_req(SeedToKeyReq self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_list_prim_u_8_strict(self.seed, serializer);
    sse_encode_String(self.path, serializer);
  }

  @protected
  void sse_encode_sign_options(SignOptions self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_bool(self.trustWitnessUtxo, serializer);
    sse_encode_opt_box_autoadd_u_32(self.assumeHeight, serializer);
    sse_encode_bool(self.allowAllSighashes, serializer);
    sse_encode_bool(self.removePartialSigs, serializer);
    sse_encode_bool(self.tryFinalize, serializer);
    sse_encode_bool(self.finalizeMineOnly, serializer);
    sse_encode_bool(self.signWithTapInternalKey, serializer);
    sse_encode_bool(self.allowGrinding, serializer);
  }

  @protected
  void sse_encode_signature_ffi(SignatureFFI self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_opt_list_prim_u_8_strict(self.publicKey, serializer);
    sse_encode_opt_list_prim_u_8_strict(self.signature, serializer);
  }

  @protected
  void sse_encode_sled_db_configuration(
      SledDbConfiguration self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_String(self.path, serializer);
    sse_encode_String(self.treeName, serializer);
  }

  @protected
  void sse_encode_sqlite_db_configuration(
      SqliteDbConfiguration self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_String(self.path, serializer);
  }

  @protected
  void sse_encode_transaction_details(
      TransactionDetails self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_opt_String(self.serializedTx, serializer);
    sse_encode_String(self.txid, serializer);
    sse_encode_u_64(self.received, serializer);
    sse_encode_u_64(self.sent, serializer);
    sse_encode_opt_box_autoadd_u_64(self.fee, serializer);
    sse_encode_opt_box_autoadd_block_time(self.confirmationTime, serializer);
  }

  @protected
  void sse_encode_tx_bytes(TxBytes self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_String(self.txId, serializer);
    sse_encode_list_prim_u_8_strict(self.bytes, serializer);
  }

  @protected
  void sse_encode_tx_in(TxIn self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_out_point(self.previousOutput, serializer);
    sse_encode_script(self.scriptSig, serializer);
    sse_encode_u_32(self.sequence, serializer);
    sse_encode_list_String(self.witness, serializer);
  }

  @protected
  void sse_encode_tx_out(TxOut self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_u_64(self.value, serializer);
    sse_encode_script(self.scriptPubkey, serializer);
  }

  @protected
  void sse_encode_tx_out_foreign(TxOutForeign self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_u_64(self.value, serializer);
    sse_encode_String(self.scriptPubkey, serializer);
  }

  @protected
  void sse_encode_u_32(int self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    serializer.buffer.putUint32(self);
  }

  @protected
  void sse_encode_u_64(BigInt self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    serializer.buffer.putBigUint64(self);
  }

  @protected
  void sse_encode_u_8(int self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    serializer.buffer.putUint8(self);
  }

  @protected
  void sse_encode_unit(void self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
  }

  @protected
  void sse_encode_user_pass(UserPass self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_String(self.username, serializer);
    sse_encode_String(self.password, serializer);
  }

  @protected
  void sse_encode_usize(BigInt self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    serializer.buffer.putBigUint64(self);
  }

  @protected
  void sse_encode_witness_version(
      WitnessVersion self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.index, serializer);
  }

  @protected
  void sse_encode_word_count(WordCount self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.index, serializer);
  }
}

@sealed
class BdkDescriptorImpl extends RustOpaque implements BdkDescriptor {
  // Not to be used by end users
  BdkDescriptorImpl.frbInternalDcoDecode(List<dynamic> wire)
      : super.frbInternalDcoDecode(wire, _kStaticData);

  // Not to be used by end users
  BdkDescriptorImpl.frbInternalSseDecode(BigInt ptr, int externalSizeOnNative)
      : super.frbInternalSseDecode(ptr, externalSizeOnNative, _kStaticData);

  static final _kStaticData = RustArcStaticData(
    rustArcIncrementStrongCount:
        RustLib.instance.api.rust_arc_increment_strong_count_BdkDescriptor,
    rustArcDecrementStrongCount:
        RustLib.instance.api.rust_arc_decrement_strong_count_BdkDescriptor,
    rustArcDecrementStrongCountPtr:
        RustLib.instance.api.rust_arc_decrement_strong_count_BdkDescriptorPtr,
  );
}

@sealed
class BlockchainInstanceImpl extends RustOpaque implements BlockchainInstance {
  // Not to be used by end users
  BlockchainInstanceImpl.frbInternalDcoDecode(List<dynamic> wire)
      : super.frbInternalDcoDecode(wire, _kStaticData);

  // Not to be used by end users
  BlockchainInstanceImpl.frbInternalSseDecode(
      BigInt ptr, int externalSizeOnNative)
      : super.frbInternalSseDecode(ptr, externalSizeOnNative, _kStaticData);

  static final _kStaticData = RustArcStaticData(
    rustArcIncrementStrongCount:
        RustLib.instance.api.rust_arc_increment_strong_count_BlockchainInstance,
    rustArcDecrementStrongCount:
        RustLib.instance.api.rust_arc_decrement_strong_count_BlockchainInstance,
    rustArcDecrementStrongCountPtr: RustLib
        .instance.api.rust_arc_decrement_strong_count_BlockchainInstancePtr,
  );
}

@sealed
class WalletInstanceImpl extends RustOpaque implements WalletInstance {
  // Not to be used by end users
  WalletInstanceImpl.frbInternalDcoDecode(List<dynamic> wire)
      : super.frbInternalDcoDecode(wire, _kStaticData);

  // Not to be used by end users
  WalletInstanceImpl.frbInternalSseDecode(BigInt ptr, int externalSizeOnNative)
      : super.frbInternalSseDecode(ptr, externalSizeOnNative, _kStaticData);

  static final _kStaticData = RustArcStaticData(
    rustArcIncrementStrongCount:
        RustLib.instance.api.rust_arc_increment_strong_count_WalletInstance,
    rustArcDecrementStrongCount:
        RustLib.instance.api.rust_arc_decrement_strong_count_WalletInstance,
    rustArcDecrementStrongCountPtr:
        RustLib.instance.api.rust_arc_decrement_strong_count_WalletInstancePtr,
  );
}

// This file is automatically generated, so please do not edit it.
// Generated by `flutter_rust_bridge`@ 2.0.0.

// ignore_for_file: invalid_use_of_internal_member, unused_import, unnecessary_import

import '../frb_generated.dart';
import 'package:flutter_rust_bridge/flutter_rust_bridge_for_generated.dart';
import 'package:freezed_annotation/freezed_annotation.dart' hide protected;
part 'types.freezed.dart';

@freezed
sealed class AddressIndex with _$AddressIndex {
  const AddressIndex._();

  /// Return a new address after incrementing the current descriptor index.
  const factory AddressIndex.newIndex() = AddressIndex_NewIndex;

  /// Return the address for the current descriptor index if it has not been used
  /// in a received transaction. Otherwise, return a new address as with AddressIndex.NewIndex.
  /// Use with caution, if the wallet has not yet detected an address has been used
  /// it could return an already used address. This function is primarily meant for situations
  /// where the caller is untrusted; for example when deriving donation addresses on-demand
  /// for a public web page.
  const factory AddressIndex.lastUnused() = AddressIndex_LastUnused;

  /// Return the address for a specific descriptor index. Does not change the current descriptor
  /// index used by `AddressIndex` and `AddressIndex.LastUsed`.
  /// Use with caution, if an index is given that is less than the current descriptor index
  /// then the returned address may have already been used.
  const factory AddressIndex.peek({
    required int index,
  }) = AddressIndex_Peek;

  /// Return the address for a specific descriptor index and reset the current descriptor index
  /// used by `AddressIndex` and `AddressIndex.LastUsed` to this value.
  /// Use with caution, if an index is given that is less than the current descriptor index
  /// then the returned address and subsequent addresses returned by calls to `AddressIndex`
  /// and `AddressIndex.LastUsed` may have already been used. Also if the index is reset to a
  /// value earlier than the Blockchain stopGap (default is 20) then a
  /// larger stopGap should be used to monitor for all possibly used addresses.
  const factory AddressIndex.reset({
    required int index,
  }) = AddressIndex_Reset;
}

/// A derived address and the index it was found at for convenience this automatically
/// derefs to [Address].
class AddressInfo {
  ///Child index of this address
  final int index;

  /// Address
  final String address;

  const AddressInfo({
    required this.index,
    required this.address,
  });

  @override
  int get hashCode => index.hashCode ^ address.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is AddressInfo &&
          runtimeType == other.runtimeType &&
          index == other.index &&
          address == other.address;
}

/// Local Wallet's Balance
class Balance {
  final BigInt immature;

  /// Unconfirmed UTXOs generated by a wallet tx
  final BigInt trustedPending;

  /// Unconfirmed UTXOs received from an external wallet
  final BigInt untrustedPending;

  /// Confirmed and immediately spendable balance
  final BigInt confirmed;

  /// Get sum of trusted_pending and confirmed coins
  final BigInt spendable;

  /// Get the whole balance visible to the wallet
  final BigInt total;

  const Balance({
    required this.immature,
    required this.trustedPending,
    required this.untrustedPending,
    required this.confirmed,
    required this.spendable,
    required this.total,
  });

  @override
  int get hashCode =>
      immature.hashCode ^
      trustedPending.hashCode ^
      untrustedPending.hashCode ^
      confirmed.hashCode ^
      spendable.hashCode ^
      total.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is Balance &&
          runtimeType == other.runtimeType &&
          immature == other.immature &&
          trustedPending == other.trustedPending &&
          untrustedPending == other.untrustedPending &&
          confirmed == other.confirmed &&
          spendable == other.spendable &&
          total == other.total;
}

/// The result after calling the TxBuilder finish() function. Contains unsigned PSBT and
/// transaction details.
class BdkTxBuilderResult {
  final String field0;
  final TransactionDetails field1;

  const BdkTxBuilderResult({
    required this.field0,
    required this.field1,
  });

  @override
  int get hashCode => field0.hashCode ^ field1.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is BdkTxBuilderResult &&
          runtimeType == other.runtimeType &&
          field0 == other.field0 &&
          field1 == other.field1;
}

///Block height and timestamp of a block
class BlockTime {
  ///Confirmation block height
  final int height;

  ///Confirmation block timestamp
  final BigInt timestamp;

  const BlockTime({
    required this.height,
    required this.timestamp,
  });

  @override
  int get hashCode => height.hashCode ^ timestamp.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is BlockTime &&
          runtimeType == other.runtimeType &&
          height == other.height &&
          timestamp == other.timestamp;
}

enum ChangeSpendPolicy {
  changeAllowed,
  onlyChange,
  changeForbidden,
  ;
}

class ForeignUtxo {
  /// Reference to a transaction output
  final OutPoint outpoint;

  ///Transaction output
  final TxOutForeign txout;

  const ForeignUtxo({
    required this.outpoint,
    required this.txout,
  });

  @override
  int get hashCode => outpoint.hashCode ^ txout.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is ForeignUtxo &&
          runtimeType == other.runtimeType &&
          outpoint == other.outpoint &&
          txout == other.txout;
}

/// Types of keychains
enum KeychainKind {
  extern,

  /// Internal, usually used for change outputs
  intern,
  ;
}

/// The cryptocurrency to act on
enum Network {
  /// Bitcoin’s testnet
  testnet,

  /// Bitcoin’s regtest
  regtest,

  /// Classic Bitcoin
  bitcoin,

  /// Bitcoin’s signet
  signet,
  ;
}

/// A reference to a transaction output.
class OutPoint {
  /// The referenced transaction's txid.
  final String txid;

  /// The index of the referenced output in its transaction's vout.
  final int vout;

  const OutPoint({
    required this.txid,
    required this.vout,
  });

  @override
  int get hashCode => txid.hashCode ^ vout.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is OutPoint &&
          runtimeType == other.runtimeType &&
          txid == other.txid &&
          vout == other.vout;
}

@freezed
sealed class Payload with _$Payload {
  const Payload._();

  /// P2PKH address.
  const factory Payload.pubkeyHash({
    required Uint8List pubkeyHash,
  }) = Payload_PubkeyHash;

  /// P2SH address.
  const factory Payload.scriptHash({
    required Uint8List scriptHash,
  }) = Payload_ScriptHash;

  /// Segwit address.
  const factory Payload.witnessProgram({
    /// The witness program version.
    required WitnessVersion version,

    /// The witness program.
    required Uint8List program,
  }) = Payload_WitnessProgram;
}

@freezed
sealed class RbfValue with _$RbfValue {
  const RbfValue._();

  const factory RbfValue.rbfDefault() = RbfValue_RbfDefault;
  const factory RbfValue.value(
    int field0,
  ) = RbfValue_Value;
}

/// A Bitcoin script.
class Script {
  final Uint8List internal;

  const Script({
    required this.internal,
  });

  @override
  int get hashCode => internal.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is Script &&
          runtimeType == other.runtimeType &&
          internal == other.internal;
}

/// A output script and an amount of satoshis.
class ScriptAmount {
  final Script script;
  final BigInt amount;

  const ScriptAmount({
    required this.script,
    required this.amount,
  });

  @override
  int get hashCode => script.hashCode ^ amount.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is ScriptAmount &&
          runtimeType == other.runtimeType &&
          script == other.script &&
          amount == other.amount;
}

/// A wallet transaction
class TransactionDetails {
  final String? serializedTx;

  /// Transaction id.
  final String txid;

  /// Received value (sats)
  /// Sum of owned outputs of this transaction.
  final BigInt received;

  /// Sent value (sats)
  /// Sum of owned inputs of this transaction.
  final BigInt sent;

  /// Fee value (sats) if confirmed.
  /// The availability of the fee depends on the backend. It's never None with an Electrum
  /// Server backend, but it could be None with a Bitcoin RPC node without txindex that receive
  /// funds while offline.
  final BigInt? fee;

  /// If the transaction is confirmed, contains height and timestamp of the block containing the
  /// transaction, unconfirmed transaction contains `None`.
  final BlockTime? confirmationTime;

  const TransactionDetails({
    this.serializedTx,
    required this.txid,
    required this.received,
    required this.sent,
    this.fee,
    this.confirmationTime,
  });

  @override
  int get hashCode =>
      serializedTx.hashCode ^
      txid.hashCode ^
      received.hashCode ^
      sent.hashCode ^
      fee.hashCode ^
      confirmationTime.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is TransactionDetails &&
          runtimeType == other.runtimeType &&
          serializedTx == other.serializedTx &&
          txid == other.txid &&
          received == other.received &&
          sent == other.sent &&
          fee == other.fee &&
          confirmationTime == other.confirmationTime;
}

/// TxBytes with tx_id and bytes
class TxBytes {
  /// The value of the output, in satoshis.
  final String txId;

  /// The script which must be satisfied for the output to be spent.
  final Uint8List bytes;

  const TxBytes({
    required this.txId,
    required this.bytes,
  });

  @override
  int get hashCode => txId.hashCode ^ bytes.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is TxBytes &&
          runtimeType == other.runtimeType &&
          txId == other.txId &&
          bytes == other.bytes;
}

class TxIn {
  final OutPoint previousOutput;
  final Script scriptSig;
  final int sequence;
  final List<String> witness;

  const TxIn({
    required this.previousOutput,
    required this.scriptSig,
    required this.sequence,
    required this.witness,
  });

  @override
  int get hashCode =>
      previousOutput.hashCode ^
      scriptSig.hashCode ^
      sequence.hashCode ^
      witness.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is TxIn &&
          runtimeType == other.runtimeType &&
          previousOutput == other.previousOutput &&
          scriptSig == other.scriptSig &&
          sequence == other.sequence &&
          witness == other.witness;
}

/// A transaction output, which defines new coins to be created from old ones.
class TxOut {
  /// The value of the output, in satoshis.
  final BigInt value;

  /// The address of the output.
  final Script scriptPubkey;

  const TxOut({
    required this.value,
    required this.scriptPubkey,
  });

  @override
  int get hashCode => value.hashCode ^ scriptPubkey.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is TxOut &&
          runtimeType == other.runtimeType &&
          value == other.value &&
          scriptPubkey == other.scriptPubkey;
}

class TxOutForeign {
  /// The value of the output, in satoshis.
  final BigInt value;

  /// The script which must be satisfied for the output to be spent.
  final String scriptPubkey;

  const TxOutForeign({
    required this.value,
    required this.scriptPubkey,
  });

  @override
  int get hashCode => value.hashCode ^ scriptPubkey.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is TxOutForeign &&
          runtimeType == other.runtimeType &&
          value == other.value &&
          scriptPubkey == other.scriptPubkey;
}

enum WitnessVersion {
  /// Initial version of witness program. Used for P2WPKH and P2WPK outputs
  v0,

  /// Version of witness program used for Taproot P2TR outputs.
  v1,

  /// Future (unsupported) version of witness program.
  v2,

  /// Future (unsupported) version of witness program.
  v3,

  /// Future (unsupported) version of witness program.
  v4,

  /// Future (unsupported) version of witness program.
  v5,

  /// Future (unsupported) version of witness program.
  v6,

  /// Future (unsupported) version of witness program.
  v7,

  /// Future (unsupported) version of witness program.
  v8,

  /// Future (unsupported) version of witness program.
  v9,

  /// Future (unsupported) version of witness program.
  v10,

  /// Future (unsupported) version of witness program.
  v11,

  /// Future (unsupported) version of witness program.
  v12,

  /// Future (unsupported) version of witness program.
  v13,

  /// Future (unsupported) version of witness program.
  v14,

  /// Future (unsupported) version of witness program.
  v15,

  /// Future (unsupported) version of witness program.
  v16,
  ;
}

///Type describing entropy length (aka word count) in the mnemonic
enum WordCount {
  ///12 words mnemonic (128 bits entropy)
  words12,

  ///18 words mnemonic (192 bits entropy)
  words18,

  ///24 words mnemonic (256 bits entropy)
  words24,
  ;
}
